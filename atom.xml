<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-01T03:06:18.332Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/02/01/hello-world/"/>
    <id>http://example.com/2023/02/01/hello-world/</id>
    <published>2023-02-01T03:06:18.332Z</published>
    <updated>2023-02-01T03:06:18.332Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mac系统安装OpenResty及使用</title>
    <link href="http://example.com/2022/03/17/Mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85OpenResty%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/03/17/Mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85OpenResty%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-17T01:30:05.000Z</published>
    <updated>2023-02-07T02:32:33.857Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/DoggieXue/Image-Home@master/20230207/laoshan-tiesuoqiao.xo3wh4cjz1c.jpg" alt="laoshan-tiesuoqiao"><br><a class="link"   href="https://openresty.org/cn/installation.html" >OpenResty官方安装文档<i class="fas fa-external-link-alt"></i></a>强烈推荐MacOS使用<a class="link"   href="https://brew.sh/" >homebrew<i class="fas fa-external-link-alt"></i></a>包管理工具安装 。但是，对于使用老版本Mac系统（如10.13.6）的用户来说不是很友好，安装过程可能会找不到各种依赖、变量等，不如手动编译源码安装OpenResty。<br>参考<a class="link"   href="https://www.runoob.com/w3cnote/openresty-intro.html" >Linux下安装OpenResty<i class="fas fa-external-link-alt"></i></a>在Mac上编译安装：</p><p>安装前准备<br>安装OpenResty前确保当前机器有以下依赖库：</p><ul><li>perl 5.6.1+</li><li>libreadline</li><li>libpcre</li><li>libssl</li></ul><p>参考<a class="link"   href="https://www.toutiao.com/article/7064948180328202766/?group_id=7064948180328202766&wid=1675737099214" >Linux系统非root用户下安装Nginx<i class="fas fa-external-link-alt"></i></a>来安装pcre和openssl即可。</p><h1 id="下载源码包、编译、安装"><a href="#下载源码包、编译、安装" class="headerlink" title="下载源码包、编译、安装"></a>下载源码包、编译、安装</h1><pre><code>wget https://openresty.org/download/openresty-1.19.3.2.tar.gztar xzvf openresty-1.19.3.2.tar.gz       # 解压cd openresty-1.19.3.2/ ./configuremake make install</code></pre><p>默认情况下程序会被安装到 &#x2F;usr&#x2F;local&#x2F;openresty 目录。该目录下的nginx目录就是独立的Nginx服务。<br><img src="https://cdn.staticaly.com/gh/DoggieXue/Image-Home@master/20230207/openresty.6n9g81ys0uc0.jpg" alt="openresty"></p><h1 id="配置PATH环境变量"><a href="#配置PATH环境变量" class="headerlink" title="配置PATH环境变量"></a>配置PATH环境变量</h1><p>方便操作OpenResty，因为Nginx&#x2F;OpenResty发布包中并没有提供好的启动、停止脚本，配置完后，就可以在终端直接使用nginx命令了。</p><pre><code>vi ~/.zshrc#添加如下配置export PATH=/usr/local/openresty/nginx/sbin:$PATH</code></pre><h1 id="命令及参数详解"><a href="#命令及参数详解" class="headerlink" title="命令及参数详解"></a>命令及参数详解</h1><p>OpenResty 的原始启动命令为 nginx，其参数有-v、-t、-p、-c、-s 等，使用说明如下：</p><h2 id="v参数"><a href="#v参数" class="headerlink" title="-v参数"></a>-v参数</h2><p>表示查看Nginx版本</p><pre><code>➜  ~ nginx -vnginx version: openresty/1.13.6.2</code></pre><h2 id="c参数"><a href="#c参数" class="headerlink" title="-c参数"></a>-c参数</h2><p>指定一个Nginx配置文件来替换默认的Nginx配置文件</p><pre><code>#单独建一个目录，并在目录中创建logs和conf目录mkdir ~/Software/openresty/workcd ~/Software/openresty/workmkdir logs/ conf/</code></pre><p>在conf目录下，定义一个后缀为.conf的文件，文件内容如下</p><pre><code>worker_processes  1;error_log logs/error.log;events &#123;    worker_connections 1024;&#125;http &#123;    server &#123;        listen 8080;        location / &#123;            default_type text/html;            content_by_lua &#39;                ngx.say(&quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;)            &#39;;        &#125;    &#125;&#125;</code></pre><p>启动Nginx：</p><pre><code>#若在上一步新建的目录下：cd ~/Software/openresty/work#执行下面的命令启动➜  work nginx -p ./ -c conf/nginx.conf #若在其他目录，比如用户目录➜  ~ nginx -c ~/Software/openresty/work/conf/nginx.conf </code></pre><p><img src="https://cdn.staticaly.com/gh/DoggieXue/Image-Home@master/20230207/start-nginx.6a3g0n9q2740.jpg" alt="start-nginx"></p><h2 id="p参数"><a href="#p参数" class="headerlink" title="-p参数"></a>-p参数</h2><p>表示设置前缀路径<br><code>-p ./</code>表示将当前目录作为前缀路径，也就是说-c后面指定的配置文件<code>conf/nginx.conf</code>中，所用到的相对路径都加上这个前缀。<br><code>-p ./</code> 等价于 <code>-p pwd/</code></p><h2 id="t参数"><a href="#t参数" class="headerlink" title="-t参数"></a>-t参数</h2><p>表示测试Nginx配置文件语法是否正确<br>若不能确定编写的Nginx配置文件语法的正确性，就使用-t参数，指定某个配置文件进行检测。不加配置文件路径，默认检测Nginx服务目录下的配置文件。<br><img src="https://cdn.staticaly.com/gh/DoggieXue/Image-Home@master/20230207/nginx-t.e2ijvl8zdf4.jpg" alt="nginx-t"></p><h2 id="s参数"><a href="#s参数" class="headerlink" title="-s参数"></a>-s参数</h2><p>表示给Nginx进程发送信号，包含stop(停止)、reload（重新加载）</p><pre><code>➜  ~ nginx -p ~/Software/openresty/work/ -c conf/nginx.conf -s reload➜  ~ ➜  ~ ps -ef|grep nginx                                                   0  1564     1   0 11:09下午 ??         0:00.00 nginx: master process nginx    -2  1565  1564   0 11:09下午 ??         0:00.00 nginx: worker process    0  2345     1   0 11:40下午 ??         0:00.01 nginx: master process nginx -p ./ -c conf/nginx.conf        -2  2833  2345   0 11:51下午 ??         0:00.00 nginx: worker process        501  2845   495   0 11:51下午 ttys000    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox nginx➜  ~ ➜  ~ nginx -p ~/Software/openresty/work/ -c conf/nginx.conf -s stop  ➜  ~ ➜  ~ ps -ef|grep nginx    0  1564     1   0 11:09下午 ??         0:00.00 nginx: master process nginx    -2  1565  1564   0 11:09下午 ??         0:00.00 nginx: worker process    501  2882   495   0 11:52下午 ttys000    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox nginx</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>终端下输入curl <a class="link"   href="http://localhost:8080/" >http://localhost:8080<i class="fas fa-external-link-alt"></i></a></p><pre><code>➜  ~ curl http://localhost:8080&lt;p&gt;Hello, World!&lt;/p&gt;➜  ~ </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.staticaly.com/gh/DoggieXue/Image-Home@master/20230207/laoshan-tiesuoqiao.xo3wh4cjz1c.jpg&quot; alt=&quot;laoshan-tiesuoqiao&quot;&gt;</summary>
      
    
    
    
    <category term="Nginx" scheme="http://example.com/categories/Nginx/"/>
    
    
    <category term="Nginx/OpenResty" scheme="http://example.com/tags/Nginx-OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>Nginx/OpenResty理论基础</title>
    <link href="http://example.com/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2022-02-17T08:54:21.000Z</published>
    <updated>2023-02-07T01:24:03.871Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx是一个高性能的HTTP和反向代理服务器，生产场景中几乎都会用到，利用Nginx+Lua可以实现高并发编程。<br>Nginx有以下三个社区分支：</p><ul><li>Nginx官方：更新迭代快，提供免费版和商业版。</li><li>Tengine：是由淘宝网发起的Web服务器项目。在Nginx的基础上针对大访问量网站的需求添加了很多高级的特性和功能。</li><li>OpenResty：将LuaJIT VM 嵌入Nginx中，实现了OpenResty这个高性能服务端解决方案。OpenResty是一个基于Nginx和Lua的高性能Web平台，其内部集成了大量精良的Lua库，第三方模块以及大多数的依赖项，用于方便地搭建能够处理超高并发、扩展性极高的动态Web应用、Web服务和动态网关。</li></ul><p>OpenResty的目标是让Web服务直接跑在Nginx服务内部，充分利用Nginx的非阻塞I&#x2F;O模型，不仅对HTTP客户端请求，甚至对远程后端（MySQL、PostgreSQL、memcached及Redis）都进行一致的高性能响应。<br>OpenResty通过汇聚各种设计精良的Nginx模块，从而将Nginx有效地变成了强大的通用Web应用平台，使得Web开发工程师和系统开发工程师可以使用Lua脚本语言调用Nginx支持的各种C及Lua模块，快速构造出足以胜任10KB乃至1000KB以上单机并发连接的高性能Web应用系统。</p><h1 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h1><p>两者都是代理服务中，进行客户端请求的转发</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>客户端非常明确要访问的服务器地址，客户端需要配置目标服务器的IP和端口信息。一般来说，正向代理服务器是一台和客户端网络连通的局域网内部的机器或者是可以打通两个隔离网络的双网卡机器。通过正向代理，客户端的HTTP请求可以转发到之前与客户端网络不通的其他不同的目标服务器。<br>正向代理的主要场景是客户端。由于网络不通等物理原因，需要通过正向代理服务器这种中间转发环节顺利访问目标服务器，也可以通过正向代理服务器对客户端某些信息进行一些伪装和改变。<br><img src="https://cdn.staticaly.com/gh/DoggieXue/Image-Home@master/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.236oysfvj51c.jpg" alt="正向代理"></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>客户端不知道目标服务器的信息，代理服务器就像是原始的目标服务器，客户端不需要进行任何特别的设置。反向代理最大的特点是客户端不知道目标服务器地址。<br>反向代理的主要场景是服务端。服务提供方可以通过反向代理服务器轻松实现目标服务器的动态切换，实现多目标服务器的负载均衡等。<br><img src="https://cdn.staticaly.com/gh/DoggieXue/Image-Home@master/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.1f7d00ia2lgg.jpg" alt="反向代理"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正向代理（如Squid、Proxy）是对客户端的伪装，隐藏了客户端的IP、头部或者其他信息，服务器得到的伪装过的客户端信息；<br>反向代理（如Nginx、Apache）是对目标服务器的伪装，隐藏了目标服务器的IP、头部或者其他信息，客户端得到的是伪装过的目标服务器信息。</p><h1 id="Nginx核心原理"><a href="#Nginx核心原理" class="headerlink" title="Nginx核心原理"></a>Nginx核心原理</h1><p>Nginx的核心原理包括Reactor模型、Nginx的模块化设计、Nginx的请求处理阶段。</p><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p>Nginx对高并发IO的处理使用了Reactor事件驱动模型。该模型的基本组件有</p><ul><li>事件收集器：负责收集worker进程的各种I&#x2F;O请求。</li><li>事件发送器：负责将IO事件发送到事件处理器。</li><li>事件处理器：负责各种事件的响应工作。</li></ul><p>Reactor模型的核心思想是：基于操作系统提供的多路I&#x2F;O复用技术，将所有要处理的I&#x2F;O事件注册到一个中心I&#x2F;O多路复用器上，同时主线程阻塞在多路复用器上，一旦有I&#x2F;O事件到来或者准备就绪(文件描述符或Socket可读、写)，多路复用器返回并将事先注册的相应I&#x2F;O事件分发到对应的处理器中。</p><h2 id="Nginx的两类进程"><a href="#Nginx的两类进程" class="headerlink" title="Nginx的两类进程"></a>Nginx的两类进程</h2><p>Nginx启动后会以daemon方式在后台运行，其后台有两类进程：</p><ul><li>Master进程：又叫管理者进程。主要负责调度Worker工作进程，比如加载配置文件、启动工作进程、接收来自外界的信号、向各Worker进程发送信号、监控Worker进程的运行状态等。同时负责创建监听套接字接口，交由Worker进程进行监听。</li><li>Worker进程：又叫工作进程。主要用来处理网络事件，当一个Worker进程在接收一个连接通道后，就开始读取请求、解析请求、处理请求，处理完成产生数据后，再返回给客户端，最后断开连接通道。各Worker进程之间是对等且独立的，它们同等竞争来自客户端的请求，一个请求只能在一个Worker进程中处理。</li></ul><h2 id="Nginx的模块化设计"><a href="#Nginx的模块化设计" class="headerlink" title="Nginx的模块化设计"></a>Nginx的模块化设计</h2><p>高度模块化的设计是Nginx的架构基础。各模块之间严格遵循“高内聚、低耦合”的原则。在Nginx实现中，一个模块包含一系列命令（cmd）和这些命令相对应的处理函数（cmd-&gt;handler）。Nginx的Worker进程在执行过程中会通过配置文件的配置指令定位到对应的功能模块的某个命令，然后调用命令对应的处理函数来完成相应的处理。<br>Nginx的模块结构图：<br><img src="https://cdn.staticaly.com/gh/DoggieXue/Image-Home@master/Nginx%E6%A8%A1%E5%9D%97.2t8gq8ffo1o0.jpg" alt="Nginx模块"><br>Nginx的主要模块说明：</p><ul><li>Core核心模块：是Nginx服务器正常运行必不可少的模块，提供错误日志记录、配置文件解析、Reactor事件驱动机制、进程管理等核心功能。</li><li>标准HTTP模块：主要提供HTTP协议解析相关的功能，比如端口配置、网页编码设置、HTTP响应头设置等。</li><li>可选HTTP模块：主要用于扩展标准的HTTP功能，让Nginx能处理一些特殊的服务，如Flash多媒体传输、网络传输压缩、安全协议SSL的支持。</li><li>邮件服务模块：主要用于支持Nginx的邮件服务，包括对POP3协议、IMAP协议和SMTP协议的支持。</li><li>第三方模块：为了扩展Nginx服务器功能，定制开发的，如JSON支持、Lua支持。</li></ul><h2 id="Nginx配置文件上下文结构"><a href="#Nginx配置文件上下文结构" class="headerlink" title="Nginx配置文件上下文结构"></a>Nginx配置文件上下文结构</h2><p>Nginx配置文件包含若干配置项，每个配置项由配置指令和指令参数两部分组成。<br>Nginx的配置项的具体功能与其所处的作用域（上下文、配置块）是强相关的。Nginx指令的作用域配置块大致分为5种，其层次关系如图：<br><img src="https://cdn.staticaly.com/gh/DoggieXue/Image-Home@master/20230207/Nginx%E4%B8%8A%E4%B8%8B%E6%96%87.4kfdkn76ms20.jpg" alt="Nginx上下文"><br>一个标准的Nginx基本配置文件nginx.conf上下文结构如下：</p><pre><code>... #main全局配置快，可配置工作进程数events &#123; #事件处理模型配置块，例如IO读写模型、连接数等    ...  &#125;http &#123; #http协议配置块    ... #http协议的全局配置快server &#123; #虚拟服务配置块1        location [PATTERN] &#123; #路由规则配置快1        ...    &#125;        location [PATTERN] &#123; #路由规则配置快2        ...    &#125;&#125;server &#123; #虚拟服务配置块2    ...&#125;... #其他http协议的全局配置&#125;main &#123;    #mail服务配置块    ...     #email相关协议，如SMTP、IMAP、POP3等&#125;</code></pre><p>除了基本配置文件外，Nginx还有如下配置文件：</p><ul><li>mime.type：与MIME类型相关的配置文件</li><li>fastcgi.conf：与FastCGI相关的配置文件。</li><li>proxy.conf：与Proxy相关的配置文件。</li><li>sites.conf：单独配置Nginx的提供的虚拟主机。</li></ul><h2 id="Nginx的请求处理流程"><a href="#Nginx的请求处理流程" class="headerlink" title="Nginx的请求处理流程"></a>Nginx的请求处理流程</h2><p>Nginx中HTTP请求的处理流程可以分为4步：</p><p>1、读取解析请求行；<br>2、读取解析请求头；<br>3、多阶段处理，即执行handle处理器列表；<br>4、将结果返回给客户端</p><p>Nginx把HTTP请求处理划分成了11个阶段，在完成前两步处理后，Nginx将整个请求封装到一个请求结构体ngx_http_request_t实例中，该实例相当于一个Java对象，然后进入多阶段处理，执行handler处理器列表，列表中的每个handler处理器都会对请求对象进行处理，类似于Netty中的PipeLine。<br>在Nginx进行多阶段处理时，handler处理器的执行次序除了和配置文件中对应指令的配置顺序相关外，还和指令所处的阶段先后次序相关。如下如展示了多阶段处理的顺序：<br><img src="https://cdn.staticaly.com/gh/DoggieXue/Image-Home@master/20230207/Nginx%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.2uzrz1od1gw0.jpg" alt="Nginx请求处理流程"></p><h2 id="HTTP请求处理的11个阶段"><a href="#HTTP请求处理的11个阶段" class="headerlink" title="HTTP请求处理的11个阶段"></a>HTTP请求处理的11个阶段</h2><p>1、post-read阶段：标准模块的ngx_realip处理器就注册在该阶段。改写请求的来源地址，将客户端真实IP附加上，便于后端获取。<br>2、server-rewrite阶段：server块中请求地址重写阶段。<br>3、find-config阶段：配置查找阶段，根据请求URL地址去匹配location路由表达式。不支持Nginx模块注册处理程序。<br>4、rewrite阶段：请求地址重写阶段，此时，location配置块中的指令开始起作用，如breaker、if、return、rewrite、set等，三方库ngx_lua模块中的set_by_lua、rewrite_by_lua指令也注册在此阶段.<br>5、post-rewrite阶段：请求地址URI重写后提交阶段，防止递归修改URI造成死循环。不支持Nginx模块注册处理程序。<br>6、preaccess阶段：访问权限检查准备阶段。<br>7、access阶段：访问权限检查阶段。注册在该阶段的指令有ngx_http_access_module模块的指令、三方ngx_auth_request模块的指令、ngx_lua模块的指令。特别提醒：echo指令用于返回内容，在location上下文中，该指令注册在content阶段，access阶段不执行该指令的配置项。<br>8、post-access阶段：访问权限检查提交阶段。如果请求不被允许访问Nginx服务器，该阶段负责向用户返回错误响应。不支持Nginx模块注册处理程序。在access阶段可能存在多个访问控制模块的指令注册，该阶段 的satisfy指令可以用于控制它们的协作方式：<br>    a. 逻辑或操作：satisfy any。表示访问控制模块A、B、C或更多，只要其中任意一个通过就算通过。<br>    b. 逻辑与操作：satisfy all。表示访问控制模块A、B、C或更多，全部通过才算通过。<br>9、try-files阶段：可以使请求按顺序访问多个静态文件资源，直到某个静态文件资源符合条件。不支持Nginx模块注册处理程序。<br>10、content阶段：内容产生阶段，大部分HTTP模块会介入。Nginx的echo、ngx_lua中的content_by_lua指令就注册在该阶段<br>11、log阶段：日志记录模块。</p><p>Nginx将一个HTTP请求分为11个处理阶段，这样做让每个HTTP模块可以只专注于完成一个独立、简单的功能。而一个请求的完整处理过程由多个HTTP模块共同完成，可以极大地提高多个模块合作的协同性、可测试性和可扩展性。<br>同一个阶段内的指令，Nginx会按照各个指令的上下文顺序执行对应的handle处理器方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Nginx是一个高性能的HTTP和反向代理服务器，生产场景中几乎都会用到，利用Nginx+Lua可以实现高并发编程。&lt;br&gt;Nginx有以下三个社区分支：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nginx官方：更新迭代快，提供免费版和商业版。&lt;/li&gt;
&lt;li&gt;Tengine：是由淘宝</summary>
      
    
    
    
    <category term="Nginx" scheme="http://example.com/categories/Nginx/"/>
    
    
    <category term="Nginx/OpenResty" scheme="http://example.com/tags/Nginx-OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>5_JVM_类加载器_自定义加载器对复杂类的加载及类加载器命名空间实战剖析</title>
    <link href="http://example.com/2020/02/05/5-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AF%B9%E5%A4%8D%E6%9D%82%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%8F%8A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9E%E6%88%98%E5%89%96%E6%9E%90/"/>
    <id>http://example.com/2020/02/05/5-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AF%B9%E5%A4%8D%E6%9D%82%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%8F%8A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9E%E6%88%98%E5%89%96%E6%9E%90/</id>
    <published>2020-02-05T07:41:12.000Z</published>
    <updated>2023-02-06T07:48:38.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义加载器对复杂类的加载"><a href="#自定义加载器对复杂类的加载" class="headerlink" title="自定义加载器对复杂类的加载"></a>自定义加载器对复杂类的加载</h1><p>示例1</p><pre><code>/*** 创建MyCat类*/public class MyCat &#123;    public MyCat() &#123;        System.out.println(&quot;MyCat is loaded by: &quot; + this.getClass().getClassLoader());    &#125;&#125;/*** 创建MySample类*/public class MySample &#123;    public MySample() &#123;        System.out.println(&quot;MySample is loaded by: &quot; + this.getClass().getClassLoader());        new MyCat();    &#125;&#125;/*** 创建测试类，使用之前写的自定义加载器MyClassLoader加载MySample类，* 然后创建MySample类实例*/public class MyTest17 &#123;    public static void main(String[] args) throws Exception&#123;        MyClassLoader loader1 = new MyClassLoader(&quot;loader1&quot;);        Class&lt;?&gt; clazz =loader1.loadClass(&quot;com.shengsiyuan.jvm.classloader.MySample&quot;);        System.out.println(&quot;class: &quot; + clazz.hashCode());        Object object = clazz.newInstance();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code>class: 312714112MySample is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4MyCat is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4</code></pre><p>这是因为loader1在加载MySample类时会先委托其父加载器进行加载，即系统类加载器对MySample进行加载。</p><p>调整程序，将classpath下的<code>com/</code>目录移到其他地方，如<code>path=/Users/xuexiao/Downloads/classes/</code>，loader1设置加载路径为path，删除classpath下的MySample类</p><pre><code>/*** 创建测试类，使用之前写的自定义加载器MyClassLoader加载MySample类，* 然后创建MySample类实例* MySample、MyCat类保持不变，loader1设置加载路径* 删除classpath下的MySample.class */public class MyTest17 &#123;    public static void main(String[] args) throws Exception&#123;        MyClassLoader loader1 = new MyClassLoader(&quot;loader1&quot;);        loader1.setPath(&quot;/Users/xuexiao/Downloads/classes/&quot;);        Class&lt;?&gt; clazz =loader1.loadClass(&quot;com.shengsiyuan.jvm.classloader.MySample&quot;);        System.out.println(&quot;class: &quot; + clazz.hashCode());        Object object = clazz.newInstance();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code>class Name: com.shengsiyuan.jvm.classloader.MySampleclass loader Name: loader1class: 1554874502MySample is loaded by: com.shengsiyuan.jvm.classloader.MyClassLoader@12a3a380MyCat is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4</code></pre><p>前两行打印信息说明，自定义加载器中的<code>findClass</code>方法运行，<code>MySample</code>类由自定义类加载器loader1进行加载。<br>加载成功后，通过<code>newInstance()</code>方法调用<code>MySample</code>的构造方法创建<code>MySample</code>实例，在其构造方法内<code>new MyCat()</code>会造成对<code>MyCat</code>类的主动使用，因此会初始化<code>MyCat</code>类，初始化之前要先加载<code>MyCat</code>类。<br>这时实际加载<code>MyCat</code>类的类加载器应该是加载了MySample类的类加载器loader1，根据双亲委派模型，loader1会委托其父类加载器对<code>MyCat</code>进行加载，其父类加载器为系统类加载器，可以加载位于classpath下的<code>MyCat</code>，因此，出现最后一行的打印结果。</p><p>若继续删除classpath下的<code>MyCat.class</code>，则<br>运行结果：</p><pre><code>class Name: com.shengsiyuan.jvm.classloader.MySampleclass loader Name: loader1class: 1554874502MySample is loaded by: com.shengsiyuan.jvm.classloader.MyClassLoader@12a3a380class Name: com.shengsiyuan.jvm.classloader.MyCatclass loader Name: loader1MyCat is loaded by: com.shengsiyuan.jvm.classloader.MyClassLoader@12a3a380</code></pre><p>这是因为在加载<code>MySample</code>时，自定义加载器会先委托其父类加载器去加载，即由应用类加载器加载，应用类加载器继续委托其父类加载器，直到启动类加载器都不能加载<code>MySample.class</code>，自定义加载器loader1再去执行加载动作。<br>在初始化<code>MySample</code>实例时，调用<code>new MyCat();</code>导致要对MyCat进行初始化，所以要对其加载，而加载<code>MyCat</code>的类加载器应该也是loader1,它先会委托父类加载器加载，直到启动类加载器也不能加载后，再自己去加载。</p><p>重新编译后，在classpath下只删除<code>MyCat.class</code>，运行结果：</p><pre><code>class: 312714112MySample is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/shengsiyuan/jvm/classloader/MyCat    at com.shengsiyuan.jvm.classloader.MySample.&lt;init&gt;(MySample.java:14)    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)    at java.lang.Class.newInstance(Class.java:442)    at com.shengsiyuan.jvm.classloader.MyTest17.main(MyTest17.java:17)Caused by: java.lang.ClassNotFoundException: com.shengsiyuan.jvm.classloader.MyCat    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338)    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)    ... 7 more</code></pre><p>运行结果可以看出，<code>MySample</code>由系统类加载器加载，在实例化过程中，调用<code>new MyCat();</code>时，系统类加载器去加载<code>MyCat</code>，但是classpath下没有<code>MyCat.class</code>，导致异常。</p><p>继续变更，在MyCat类中添加<code>MySample</code>类的引用，这样两个类就是相互关联的关系了</p><pre><code>public class MyCat &#123;    public MyCat() &#123;        System.out.println(&quot;MyCat is loaded by: &quot; + this.getClass().getClassLoader());        //添加MySample的引用        System.out.println(&quot;from MyCat: &quot; + MySample.class);    &#125;&#125;</code></pre><p>重新编译后(classpath下不做删除操作)的运行结果：</p><pre><code>class: 312714112MySample is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4MyCat is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4from MyCat: class com.shengsiyuan.jvm.classloader.MySample</code></pre><p>此时两个类实际都由系统类加载器正常加载。</p><p>若删除classpath下的<code>MySample</code>类，运行结果是:</p><pre><code>class Name: com.shengsiyuan.jvm.classloader.MySampleclass loader Name: loader1class: 1554874502MySample is loaded by: com.shengsiyuan.jvm.classloader.MyClassLoader@12a3a380MyCat is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/shengsiyuan/jvm/classloader/MySample    at com.shengsiyuan.jvm.classloader.MyCat.&lt;init&gt;(MyCat.java:15)    at com.shengsiyuan.jvm.classloader.MySample.&lt;init&gt;(MySample.java:14)    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)    at java.lang.Class.newInstance(Class.java:442)    at com.shengsiyuan.jvm.classloader.MyTest17.main(MyTest17.java:17)Caused by: java.lang.ClassNotFoundException: com.shengsiyuan.jvm.classloader.MySample    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338)    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)    ... 8 more</code></pre><p>此时<code>MySample</code>实际由自定义加载器loader1加载，<code>MyCat</code>实际由系统类加载器加载，在<code>MyCat</code>类实例化时，要对<code>MySample</code>进行引用，因为类加载器的命名空间问题，父类加载器所加载的类无法访问子类加载器所加载的类，导致找不到<code>MySample</code></p><p>若修改<code>MySample</code>类，和<code>MyCat</code>类，只删除classpath下的<code>MySample</code>.class</p><pre><code>public class MySample &#123;    public MySample() &#123;        System.out.println(&quot;MySample is loaded by: &quot; + this.getClass().getClassLoader());        new MyCat();        //MyCat引用        System.out.println(&quot;from MySample: &quot; + MyCat.class);    &#125;&#125;public class MyCat &#123;    public MyCat() &#123;        System.out.println(&quot;MyCat is loaded by: &quot; + this.getClass().getClassLoader());    &#125;&#125;</code></pre><p>运行结果是：</p><pre><code>class Name: com.shengsiyuan.jvm.classloader.MySampleclass loader Name: loader1class: 1554874502MySample is loaded by: com.shengsiyuan.jvm.classloader.MyClassLoader@12a3a380MyCat is loaded by: sun.misc.Launcher$AppClassLoader@330bedb4</code></pre><p>此时，<code>MySample.class</code>由自定义加载器加载，<code>MyCat.class</code>由父类加载器（应用加载器）加载，根据命名空间的规则，子加载器所加载的类能够访问父加载器所加载的类。</p><p>结论如下：</p><ul><li>若一个类A中有对类B的引用，则B的class对象由加载A的加载器加载，并遵循双亲委派模型；</li><li>父加载器所加载的类无法访问子加载器所加载的类；</li><li>子加载器所加载的类能够访问父加载器所加载的类。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自定义加载器对复杂类的加载&quot;&gt;&lt;a href=&quot;#自定义加载器对复杂类的加载&quot; class=&quot;headerlink&quot; title=&quot;自定义加载器对复杂类的加载&quot;&gt;&lt;/a&gt;自定义加载器对复杂类的加载&lt;/h1&gt;&lt;p&gt;示例1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* 创</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>4_JVM_类加载器_ClassLoader源码分析与实例剖析</title>
    <link href="http://example.com/2020/02/02/4-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-ClassLoader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%89%96%E6%9E%90/"/>
    <id>http://example.com/2020/02/02/4-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-ClassLoader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%89%96%E6%9E%90/</id>
    <published>2020-02-02T07:36:07.000Z</published>
    <updated>2023-02-06T07:39:35.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获得ClassLoader的途径"><a href="#获得ClassLoader的途径" class="headerlink" title="获得ClassLoader的途径"></a>获得ClassLoader的途径</h1><ul><li>获得当前类的ClassLoader:<code>clazz.getClassLoader();</code></li><li>获得当前线程上线文的ClassLoader :<code>Thread.currentThread.getContextClassLoader();</code></li><li>获得系统的ClassLoader:<code>ClassLoader.getSystemClassLoader();</code></li><li>获得调用者的ClassLoader:<code>DriverManager.getCallerClassLoader();</code></li></ul><p>类加载器是一个加载class类的对象。ClassLoader类是一个抽象类。如果给定了一个类的二进制名字，类加载器就会试图去定位或生成一些数据，这些数据构成了该类的定义。一个典型的策略是：将给定的名字转换成文件名，然后从文件系统中读取”class文件”。</p><p>每个class对象都包含一个到定义它的ClassLoader的引用。</p><p>数组的Class对象并不是由类加载器创建的，而是由Java虚拟机在运行期自动创建的（动态生成的）。<code>Class.getClassLoader()</code>方法返回的数组类的类加载器，与数组中元素类型的类加载器是一样的。如果数组中元素类型是原生类型，则数组类是没有类加载器的。</p><pre><code>public class MyTest15 &#123;    public static void main(String[] args) &#123;        String[] strings = new String[1];        System.out.println(strings.getClass().getClassLoader());// null 启动类加载器        System.out.println(&quot;-------&quot;);         MyTest15[] myTest15s = new MyTest15[2];        System.out.println(myTest15s.getClass().getClassLoader());        System.out.println(&quot;--------&quot;);        int[] ints = new int[2];        System.out.println(ints.getClass().getClassLoader());//null 原生类型数组没有类加载器    &#125;&#125;</code></pre><p>运行结果：</p><pre><code>null-------sun.misc.Launcher$AppClassLoader@330bedb4--------null</code></pre><p>ClassLoader的应用实现子类应该继承Java虚拟机动态加载类的方式。</p><p>类加载器通常由安全管理器用于指示安全域。</p><p>ClassLoader使用委托模型(delegation model)来寻找类和资源。其每一个实例都有一个相关的父（类）加载器。当需要寻找一个类或资源时，ClassLoader实例在自己寻找之前，会委托其父加载器进行寻找。虚拟机内建的类加载器被称为”bootstrap class loader”，它没有父加载器，但可以作为ClassLoader实例的父加载器。</p><p>支持并发加载类的类加载器被称作parallel capable类加载器，这需要在加载器类初始化时调用<code>ClassLoader.registerParallelCapable()</code>方法进行注册。注意，ClassLoader类默认具备并发加载能力。然而其他自定义子类需要显示注册并发加载能力。</p><p>delegation model环境并不是严格分层的，类加载器需要具备并发加载能力，否则在加载类时会导致死锁，因为加载器锁在类加载过程中s会被持有的。</p><p>通常Java虚拟机以平台无关的方式从本地文件系统中加载类。例如，在UNIX系统中，虚拟机从CLASSPATH环境变量定义的目录中加载类。</p><p>然而，有些类并非由文件生成，可能是由其他资源生成，如网络，也可能由应用构建而成。defineClass方法将二进制数组转换成Class类，该新定义类的实例可以通过<code>Class.newInstance</code>方法创建。</p><p>由类加载器创建的对象中的方法和构造方法中会引用其他类，为确定这些引用类，Java虚拟机会调用创建该类的类加载器中的loadClass方法。</p><h1 id="自定义类加载器示例"><a href="#自定义类加载器示例" class="headerlink" title="自定义类加载器示例"></a>自定义类加载器示例</h1><pre><code>package com.shengsiyuan.jvm.classloader;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;/*** @Program jvm_lecture* @Title: MyClassLoader* @Description:* @Author: XueXiao* @Create: 2020-02-02 21:46:13*/public class MyClassLoader extends ClassLoader&#123;    private String classLoderName;    public String path;    private final String fileExtention = &quot;.class&quot;;    public MyClassLoader(String classLoderName)&#123;        super();//将系统类加载器当做该类加载器的父加载器        this.classLoderName = classLoderName;    &#125;    public MyClassLoader(ClassLoader parent, String classLoderName)&#123;        super(parent);        this.classLoderName = classLoderName;    &#125;    public void setPath(String path) &#123;        this.path=path;    &#125;    /**    * defineClass方法，将二进制数组转换成Class类    * @param className    * @return    * @throws ClassNotFoundException    */    @Override    protected Class&lt;?&gt; findClass(String className) throws ClassNotFoundException &#123;        System.out.println(&quot;findClass methord is invoked!&quot;);        System.out.println(&quot;class Name: &quot; + className);        byte[] data = loadData(className);        return defineClass(className, data, 0, data.length);    &#125;    private byte[] loadData(String className)&#123;        InputStream is = null;        byte[] data = null;        ByteArrayOutputStream baos = null;        try &#123;            className = className.replace(&quot;.&quot;,&quot;/&quot;);            is = new FileInputStream(new File(path + className + fileExtention));            baos = new ByteArrayOutputStream();            int ch;            while (-1 != (ch = is.read()))&#123;                baos.write(ch);            &#125;            data = baos.toByteArray();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                is.close();                baos.close();            &#125; catch (Exception ex) &#123;                ex.printStackTrace();            &#125;        &#125;        return data;    &#125;    public static void main(String[] args) throws Exception&#123;        MyClassLoader loader = new MyClassLoader(&quot;loader1&quot;);        //loader.setPath(&quot;/Users/xuexiao/IdeaProjects/jvm_lecture/out/production/classes/&quot;);        loader.setPath(&quot;/Users/xuexiao/Downloads/classes/&quot;);        Class&lt;?&gt; clazz = loader.loadClass(&quot;com.shengsiyuan.jvm.classloader.MyTest1&quot;);        System.out.println(clazz.hashCode());        Object object = clazz.newInstance();        System.out.println(object);        System.out.println(&quot;-----------------&quot;);        MyClassLoader loader2 = new MyClassLoader(&quot;loader2&quot;);        loader2.setPath(&quot;/Users/xuexiao/Downloads/classes/&quot;);        Class&lt;?&gt; clazz2 = loader2.loadClass(&quot;com.shengsiyuan.jvm.classloader.MyTest1&quot;);        System.out.println(clazz2.hashCode());        Object object2 = clazz2.newInstance();        System.out.println(object2);    &#125;&#125;</code></pre><p>运行前提，删除classpath下的MyTest1.class文件，运行结果：</p><pre><code>findClass methord is invoked!class Name: com.shengsiyuan.jvm.classloader.MyTest1692404036com.shengsiyuan.jvm.classloader.MyTest1@5cad8086-----------------findClass methord is invoked!class Name: com.shengsiyuan.jvm.classloader.MyTest11627674070com.shengsiyuan.jvm.classloader.MyTest1@511d50c0</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;获得ClassLoader的途径&quot;&gt;&lt;a href=&quot;#获得ClassLoader的途径&quot; class=&quot;headerlink&quot; title=&quot;获得ClassLoader的途径&quot;&gt;&lt;/a&gt;获得ClassLoader的途径&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;获得当前类的Cl</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>3_JVM_类加载器_类加载器深入解析及重要特性</title>
    <link href="http://example.com/2020/02/01/3-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2020/02/01/3-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7/</id>
    <published>2020-02-01T07:23:30.000Z</published>
    <updated>2023-02-06T07:35:11.026Z</updated>
    
    <content type="html"><![CDATA[<p>JVM使用class类的过程如下：</p><ul><li>加载： 就是把二进制形式的java类型读入java虚拟机中</li><li>连接_验证</li><li>连接_准备： 为类变量分配内存，设置默认值。但是在到达初始化之前，类变量都没有初始化为真正的初始值</li><li>连接_解析： 解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程</li><li>初始化： 为类变量赋予正确的初始值。静态变量的声明语句，以及静态代码块都被看做类的初始化语句，Java虚拟机会按照初始化语句在类文件中的先后顺序来依次执行他们。</li><li>类实例化：</li><li>使用</li><li>卸载</li><li>垃圾回收和对象终结</li></ul><h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><p>类的加载的最终产品是位于内存中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。<br>通过两种类型的类加载器进行加载</p><h2 id="Java虚拟机自带的加载器"><a href="#Java虚拟机自带的加载器" class="headerlink" title="Java虚拟机自带的加载器"></a>Java虚拟机自带的加载器</h2><ul><li>根类加载器(Bootstrap)</li><li>扩展类加载器(Extention)</li><li>系统(应用)类加载器(System)</li></ul><h2 id="用户自定义的类加载器"><a href="#用户自定义的类加载器" class="headerlink" title="用户自定义的类加载器"></a>用户自定义的类加载器</h2><ul><li><code>java.lang.ClassLoader</code>的子类</li><li>用户可以定制类的加载方式</li></ul><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它：<br>JVM规范允许类加载器在预料某各类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或文件错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）；<br>如果这个类一直没有被程序主动使用，那么类加载器就不会报告任何错误。</p><h1 id="类的验证"><a href="#类的验证" class="headerlink" title="类的验证"></a>类的验证</h1><p>类被加载后就进入到连接阶段。连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。<br>类的验证内容</p><ul><li>类文件的结构检查</li><li>语义检查</li><li>字节码验证</li><li>二进制兼容性的验证</li></ul><h1 id="类的准备"><a href="#类的准备" class="headerlink" title="类的准备"></a>类的准备</h1><p>为类的静态变量分配内存，设置默认值。但是在到达初始化之前，类变量都没有初始化为真正的初始值</p><h1 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h1><h2 id="初始化步骤："><a href="#初始化步骤：" class="headerlink" title="初始化步骤："></a>初始化步骤：</h2><ul><li>假如这个类还没有被加载和连接，那就先进行加载和连接</li><li>假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化父类</li><li>假如类中存在初始化语句，那就依次执行这些初始化语句</li></ul><h2 id="初始化时机-类的主动使用，七种-："><a href="#初始化时机-类的主动使用，七种-：" class="headerlink" title="初始化时机(类的主动使用，七种)："></a>初始化时机(类的主动使用，七种)：</h2><ul><li>创建类的实例</li><li>访问某个类或接口静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK 1.7新增的一种情况<br>当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</li><li>在初始化一个类时，并不会先初始化它所实现的接口</li><li>在初始化一个接口时，并不会先初始化它的父接口</li></ul><p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。</p><p>只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用。<br>调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p><h1 id="类实例化"><a href="#类实例化" class="headerlink" title="类实例化"></a>类实例化</h1><p>为新的对象分配内存<br>为实例变量赋默认值<br>为实例变量赋正确的初始值<br>java编译器为它编译的每一个类都至少生成一个实例初始化方法，在java的class文件中，这个实例初始化方法被称为<code>&lt;init&gt;</code>。针对源代码中每一个类的构造方法，java编译器都产生一个<code>&lt;init&gt;</code>方法</p><h1 id="类加载器详解"><a href="#类加载器详解" class="headerlink" title="类加载器详解"></a>类加载器详解</h1><p>类加载器用来把类加载到Java虚拟机中。从JDK 1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好的保证Java平台的安全。在此委托机制中，除了Java虚拟机自带的根类加载器之外，其余的类加载器都有且只有一个父加载器。当Java程序请求加载器loader1加载Simple类时，loader1首先委托自己的父加载器去加载Simple类，若父加载器能加载，则由父加载器完成加载任务，否则才由加载器loader1本身加载Simple类。<br>Java虚拟机自带了以下几种加载器</p><ul><li>根类加载器（BootStrap）：该加载器没有父加载器。它负责加载虚拟机的核心类库，如<code>java.lang.*</code>等。<code>java.lang.Object</code>类就是由根类加载器加载的。根类加载器从系统属性<code>sun.boot.class.path</code>所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统，属于虚拟机实现的一部分，它并没有继承<code>java.lang.ClassLoder</code>类。</li><li>扩展类加载器（Extention）：它的父加载器为根类加载器。它从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或者从JDK的安装目录的<code>jre/lib/ext</code>子目录（扩展目录）下加载类库，如果把用户创建的JAR文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯Java类，是<code>java.lang.ClassLoader</code>类的子类。</li><li>系统类加载器（System）：也称为应用类加载器，它的父加载器为扩展类加载器。它从环境变量classpath或者系统属性<code>java.class.path</code>所指定的目录中加载类，它是用户自定义类加载器的父加载器。系统类加载器属于纯Java类，是<code>java.lang.ClassLoader</code>类的子类。</li><li>自定义加载器：除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类<code>java.lang.ClassLoader</code>，所有用户自定义的类加载器都应该继承ClassLoader类。</li></ul><p>类加载器关系如下：<br>用户自定义类加载器 –&gt; System类加载器 –&gt; Extention类加载器 –&gt; Bootstrap类加载器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JVM使用class类的过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载： 就是把二进制形式的java类型读入java虚拟机中&lt;/li&gt;
&lt;li&gt;连接_验证&lt;/li&gt;
&lt;li&gt;连接_准备： 为类变量分配内存，设置默认值。但是在到达初始化之前，类变量都没有初始化为真正的初始值&lt;/l</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>2_JVM_类加载器_接口初始化规则与类加载器准备阶段和初始化阶段的重要意义</title>
    <link href="http://example.com/2020/01/30/2-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E6%8E%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E7%9A%84%E9%87%8D%E8%A6%81%E6%84%8F%E4%B9%89/"/>
    <id>http://example.com/2020/01/30/2-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E6%8E%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E7%9A%84%E9%87%8D%E8%A6%81%E6%84%8F%E4%B9%89/</id>
    <published>2020-01-30T07:20:02.000Z</published>
    <updated>2023-02-06T07:23:02.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口初始化规则"><a href="#接口初始化规则" class="headerlink" title="接口初始化规则"></a>接口初始化规则</h1><p>首先要明确，接口中定义的变量都为常量，<code>public static final</code>修饰符通常可以省略<br>示例：</p><pre><code>public class MyTest5 &#123;    public static void main(String[] args) &#123;        System.out.println(MyChild5.b);    &#125;&#125;interface MyParent5 &#123;    public static int a = 5;&#125;interface MyChild5 extends MyParent5 &#123;    public static int b = 6;&#125;</code></pre><p>打印结果：</p><pre><code>6</code></pre><p>当一个接口在初始化时，并不要求其父接口都完成了初始化；<br>只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化。</p><h1 id="类加载器准备阶段与初始化阶段"><a href="#类加载器准备阶段与初始化阶段" class="headerlink" title="类加载器准备阶段与初始化阶段"></a>类加载器准备阶段与初始化阶段</h1><p>判断下面程序的运行结果：</p><pre><code>public class MyTest6 &#123;    public static void main(String[] args) &#123;        Singleton singleton = Singleton.getInstance();        System.out.println(&quot;counter1: &quot; + Singleton.counter1);        System.out.println(&quot;counter2: &quot; + Singleton.counter2);    &#125;&#125;class Singleton &#123;    public static int counter1;    public static int counter2 = 0;    private Singleton singleton = new Singleton();    private Singleton() &#123;        counter1++;        counter2++;    &#125;    public Singleton getInstance()&#123;        return singleton;    &#125;&#125;</code></pre><p>运行结果：</p><pre><code>counter1: 1counter2: 1</code></pre><p>调整Singleton类中变量的顺序，再运行：</p><pre><code>public class MyTest6 &#123;    public static void main(String[] args) &#123;        Singleton singleton = Singleton.getInstance();        System.out.println(&quot;counter1: &quot; + Singleton.counter1);        System.out.println(&quot;counter2: &quot; + Singleton.counter2);    &#125;&#125;class Singleton &#123;    public static int counter1;    private Singleton singleton = new Singleton();    private Singleton() &#123;        counter1++;        counter2++;    &#125;    public static int counter2 = 0;    public Singleton getInstance()&#123;        return singleton;    &#125;&#125;</code></pre><p>运行结果：</p><pre><code>counter1: 1counter2: 0</code></pre><p>若为counter1显示赋值为1</p><pre><code>public class MyTest6 &#123;    public static void main(String[] args) &#123;        Singleton singleton = Singleton.getInstance();        System.out.println(&quot;counter1: &quot; + Singleton.counter1);        System.out.println(&quot;counter2: &quot; + Singleton.counter2);    &#125;&#125;class Singleton &#123;    public static int counter1 = 1;    private Singleton singleton = new Singleton();    private Singleton() &#123;        counter1++;        counter2++;    &#125;    public static int counter2 = 0;    public Singleton getInstance()&#123;        return singleton;    &#125;&#125;</code></pre><p>运行结果是：</p><pre><code>counter1: 2counter2: 0</code></pre><p>MyTest6主函数中，Singleton.getInstance()的调用，表明了对Singleton类主动使用，所以要初始化Singleton类。<br>在初始化之前，JVM会对Singleton类进行加载和连接，连接的第二阶段，会为counter1、counter2、和singleton赋默认值分别是0、0、null。然后再执行初始化操作：</p><ul><li>第一个例子中，调用构造方法后，counter1和counter2分别为1，初始化结束；</li><li>第二个例子中，调用构造方法后，counter1和cunter2分别为1和1，继续执行，counter2被初始化成0，初始化结束；</li><li>第三个例子中，连接阶段counter1和counter2都是0，初始化阶段，counter1被初始化为1，然后调用构造方法后，counter1和counter2分别为2和0，初始化继续，counter2变成了0</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;接口初始化规则&quot;&gt;&lt;a href=&quot;#接口初始化规则&quot; class=&quot;headerlink&quot; title=&quot;接口初始化规则&quot;&gt;&lt;/a&gt;接口初始化规则&lt;/h1&gt;&lt;p&gt;首先要明确，接口中定义的变量都为常量，&lt;code&gt;public static final&lt;/code</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>1_JVM_类加载器_编译期常量与运行期常量及数组创建的本质</title>
    <link href="http://example.com/2020/01/30/1-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%B8%B8%E9%87%8F%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <id>http://example.com/2020/01/30/1-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%B8%B8%E9%87%8F%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E7%9A%84%E6%9C%AC%E8%B4%A8/</id>
    <published>2020-01-30T01:49:34.000Z</published>
    <updated>2023-02-06T07:52:21.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译期常量"><a href="#编译期常量" class="headerlink" title="编译期常量"></a>编译期常量</h1><p>在编译期间可以确定具体值的常量，如以下示例：</p><pre><code>public class MyTest3 &#123;    public static void main(String[] args) &#123;        System.out.println(MyParent3.str);    &#125;&#125;class MyParent3 &#123;    public static final String str = &quot;hello JVM&quot;;    static &#123;        System.out.println(&quot;MyParent3 static block&quot;);    &#125;&#125;</code></pre><p>打印结果是：</p><pre><code>hello JVM</code></pre><p>因为str是一个在编译期间就可以确定值的常量</p><h1 id="运行期常量"><a href="#运行期常量" class="headerlink" title="运行期常量"></a>运行期常量</h1><p>在编译期间不能确定具体值，而是在运行期间才能确定的常量，如：</p><pre><code>public class MyTest3 &#123;    public static void main(String[] args) &#123;        System.out.println(MyParent3.str);    &#125;&#125;class MyParent3 &#123;    public static final String str = UUID.randomUUID().toString();    static &#123;        System.out.println(&quot;MyParent3 static block&quot;);    &#125;&#125;</code></pre><p>运行结果是：</p><pre><code>MyParent3 static block967b85b7-d0f9-4a8f-b00d-9f4f46552515</code></pre><p>因为当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中，这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化。</p><h1 id="数组创建本质"><a href="#数组创建本质" class="headerlink" title="数组创建本质"></a>数组创建本质</h1><p>先看以下示例：</p><pre><code>public class MyTest4 &#123;    public static void main(String[] args) &#123;        //MyParent4 myParent4 = new MyParent4();        MyParent4[] myParent4s = new MyParent4[1];    &#125;&#125;class MyParent4 &#123;    static &#123;        System.out.println(&quot;MyParent static block&quot;);    &#125;&#125;</code></pre><p>运行发现，控制台不打印任何内容，也就是说创建数组时，没有主动使用MyParent4类，也不会初始化MyParent4。那么通过new关键字创建的数组对象到底是什么类型的呢？<br>通过将其class类型打印发现:</p><pre><code>public class MyTest4 &#123;    public static void main(String[] args) &#123;        MyParent4[] myParent4s = new MyParent4[1];        System.out.println(myParent4s.getClass());        MyParent4[][] myParent4s1 = new MyParent4[1][1];        System.out.println(myParent4s1.getClass());        System.out.println(myParent4s.getClass().getSuperclass());        System.out.println(myParent4s1.getClass().getSuperclass());        int[] ints = new int[1];        System.out.println(ints.getClass());        short[] shorts = new short[1];        System.out.println(shorts.getClass());        boolean[] booleans = new boolean[1];        System.out.println(booleans.getClass());        char[] chars = new char[1];        System.out.println(chars.getClass());        byte[] bytes = new byte[1];        System.out.println(bytes.getClass());        long[] longs = new long[1];        System.out.println(longs.getClass());        float[] floats = new float[1];        System.out.println(floats.getClass());        String[] strings = new String[1];        System.out.println(strings.getClass());    &#125;&#125;class MyParent4 &#123;    static &#123;        System.out.println(&quot;MyParent static block&quot;);    &#125;&#125;</code></pre><p>运行结果是：</p><pre><code>class [Lcom.shengsiyuan.jvm.classloader.MyParent4;class [[Lcom.shengsiyuan.jvm.classloader.MyParent4;class java.lang.Objectclass java.lang.Objectclass [Iclass [Sclass [Zclass [Cclass [Bclass [Jclass [Fclass [Ljava.lang.String;</code></pre><p>结论：<br>对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为[L全类名这种形式。这种动态生成类型的父类型就是Object。<br>对于数组来说，JavaDoc经常将构成数组的元素称为Component，实际上就是将数组降低一个维度后的类型。</p><p>通过反编译结果得出两个关于数组的助记符</p><ul><li>anewarray: 创建一个引用类型的数组(如类、接口、数组)，并将其引用值压入栈顶</li><li>newarray: 创建一个指定的原生类型(如int、float、char等)的数组，并将其压入栈顶</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编译期常量&quot;&gt;&lt;a href=&quot;#编译期常量&quot; class=&quot;headerlink&quot; title=&quot;编译期常量&quot;&gt;&lt;/a&gt;编译期常量&lt;/h1&gt;&lt;p&gt;在编译期间可以确定具体值的常量，如以下示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyTest3</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>0_JVM_类加载器_类加载、连接与初始化</title>
    <link href="http://example.com/2020/01/29/0-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E3%80%81%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://example.com/2020/01/29/0-JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E3%80%81%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2020-01-29T02:53:08.000Z</published>
    <updated>2023-02-06T07:59:16.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java程序运行的过程"><a href="#Java程序运行的过程" class="headerlink" title="Java程序运行的过程"></a>Java程序运行的过程</h1><p>在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的，这样就提供了更大的灵活性，增加了更多的可能性。</p><ul><li>加载： 指的是查找并加载类的二进制数据，将类的<code>.class</code>文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个<code>java.lang.Class</code>对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中），用来封装类在方法区中的数据结构；<br>  加载.class文件的方式有：<ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip、jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件（动态代理）</li></ul></li><li>连接： 又分为三个阶段：验证、准备和解析<ul><li>验证： 确保被加载的类的正确性</li><li>准备： 为类的静态变量分配内存，并将其初始化为默认值</li><li>解析： 把类中的符号引用转换为直接引用</li></ul></li><li>初始化： 为类的静态变量赋予正确的初始值</li><li>类的使用</li><li>类的卸载</li></ul><h1 id="Java虚拟机结束生命周期的集中情况"><a href="#Java虚拟机结束生命周期的集中情况" class="headerlink" title="Java虚拟机结束生命周期的集中情况"></a>Java虚拟机结束生命周期的集中情况</h1><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h1 id="JVM对类的使用分为两种情况"><a href="#JVM对类的使用分为两种情况" class="headerlink" title="JVM对类的使用分为两种情况"></a>JVM对类的使用分为两种情况</h1><h2 id="主动使用（七种）："><a href="#主动使用（七种）：" class="headerlink" title="主动使用（七种）："></a>主动使用（七种）：</h2><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对其赋值</li><li>调用类的静态方法</li><li>反射</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类（包含main方法）</li><li>JDK 1.7开始提供的动态语言支持</li></ul><h2 id="被动使用："><a href="#被动使用：" class="headerlink" title="被动使用："></a>被动使用：</h2><p>其他使用类的方式都被看作是被动使用，不会被初始化<br>所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化他们。</p><p>示例：</p><pre><code>/*** 主动使用父类中的静态变量，子类不会被初始化*/public class MyTest1 &#123;    public static void main(String[] args) &#123;        System.out.println(MyChild1.str);    &#125;&#125;class MyParent1 &#123;    public static String str = &quot;hello world&quot;;    static &#123;        System.out.println(&quot;MyParent1 static block&quot;);    &#125;&#125;class MyChild1 extends MyParent1 &#123;    static &#123;        System.out.println(&quot;MyChild1 static block&quot;);    &#125;&#125;</code></pre><p>运行结果是</p><pre><code>MyParent1 static blockhello world</code></pre><p>如果在子类中添加静态变量并打印呢?</p><pre><code>/*** 主动使用子类中的静态变量，子类初始化之前要先初始化父类*/public class MyTest1 &#123;    public static void main(String[] args) &#123;        System.out.println(MyChild1.str1);    &#125;&#125;class MyParent1 &#123;    public static String str = &quot;hello world&quot;;    static &#123;        System.out.println(&quot;MyParent1 static block&quot;);    &#125;&#125;class MyChild1 extends MyParent1 &#123;    public static String str1 = &quot;welcome&quot;;    static &#123;        System.out.println(&quot;MyChild1 static block&quot;);    &#125;&#125;</code></pre><p>运行结果是:</p><pre><code>MyParent1 static blockMyChild1 static blockwelcome</code></pre><p>第一个例子中，实际打印父类中定义的静态变量，即对父类的主动使用，并没有主动使用子类，因此不会对子类初始化。谁定义的静态变量表示对谁的主动使用。得出如下结论：<br>对于静态变量来说，只有直接定义了该字段的类才会被初始化；</p><p>第二个例子中，实际打印子类中的静态变量，即对子类的主动使用，要初始化子类。当一个类在初始化时，要求其父类已经初始化完毕了，所以会打印父类和子类中静态代码块信息。</p><p>对于第一个例子，子类没有初始化，那么是否被加载呢？通过Java虚拟机命令，<code>-XX:+TraceClassLoading</code>观察得出，子类是被加载了</p><pre><code>...[Loaded com.shengsiyuan.jvm.classloader.MyTest1 from file:/Users/xuexiao/IdeaProjects/jvm_lecture/out/production/classes/][Loaded sun.launcher.LauncherHelper$FXHelper from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.Class$MethodArray from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar][Loaded com.shengsiyuan.jvm.classloader.MyParent1 from file:/Users/xuexiao/IdeaProjects/jvm_lecture/out/production/classes/][Loaded com.shengsiyuan.jvm.classloader.MyChild1 from file:/Users/xuexiao/IdeaProjects/jvm_lecture/out/production/classes/]MyParent1 static blockhello world[Loaded java.lang.Shutdown from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.Shutdown$Lock from /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/lib/rt.jar]</code></pre><h1 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h1><p>总体来说，有三种使用方式：<br><code>-XX:+&lt;option&gt;</code>表示用于开启option选项<br><code>-XX:-&lt;option&gt;</code>表示用于关闭option选项<br><code>-XX:&lt;option&gt;=&lt;value&gt;</code>表示将option选项赋值为value</p><h1 id="常量的本质"><a href="#常量的本质" class="headerlink" title="常量的本质"></a>常量的本质</h1><p>先看以下示例：</p><pre><code>public class MyTest2 &#123;    public static void main(String[] args) &#123;        System.out.println(MyParent2.str);    &#125;&#125;class MyParent2 &#123;    public static final String str = &quot;hello world&quot;;    static &#123;        System.out.println(&quot;MyParent2 static block&quot;);    &#125;&#125;</code></pre><p>运行结果是：</p><pre><code>hello world</code></pre><p>final 表示一个常量，不能被改变，它在编译阶段会存入到调用这个常量的方法所在类的常量池中(即str这个常量会被存入到MyTest2这个类的常量池中)，本质上调用类并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。<br>注意：这里指的是将常量存放到了MyTest2的常量池中，之后MyTest2与MyParent2就没有任何关系了，甚至可以将MyTest2的class文件删除。</p><p>以上结论可以通过反编译结果进行印证</p><pre><code>➜  classes javap -c com.shengsiyuan.jvm.classloader.MyTest2Compiled from &quot;MyTest2.java&quot;public class com.shengsiyuan.jvm.classloader.MyTest2 &#123;public com.shengsiyuan.jvm.classloader.MyTest2();    Code:    0: aload_0    1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V    4: returnpublic static void main(java.lang.String[]);    Code:    0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;    3: ldc           #4                  // String hello world    5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V    8: return&#125;➜ classes</code></pre><p><code>getstatic</code>:表示对main方法的调用；<br><code>ldc</code>: 在反编译的结果中已经是一个字符串<code>”hello world”</code>，说明<code>MyParent2.str</code>这个引用在编译阶段已经变成了具体的字符串，这个字符串就存在MyTest2的常量池中。</p><h1 id="助记符"><a href="#助记符" class="headerlink" title="助记符"></a>助记符</h1><ul><li>ldc： 表示将int、float或String类型的常量值从常量池中推送至栈顶</li><li>bipush： 表示将单字节(-128-127)的常量值推送至栈顶</li><li>sipush： 表示将一个短整型常量值(-32768-32767)推送至栈顶</li><li>iconst_1： 表示将int类型1推送至栈顶</li><li>iconst_2： 表示将int类型2推送至栈顶</li><li>iconst_3： 表示将int类型3推送至栈顶</li><li>iconst_4： 表示将int类型4推送至栈顶</li><li>iconst_5： 表示将int类型5推送至栈顶</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java程序运行的过程&quot;&gt;&lt;a href=&quot;#Java程序运行的过程&quot; class=&quot;headerlink&quot; title=&quot;Java程序运行的过程&quot;&gt;&lt;/a&gt;Java程序运行的过程&lt;/h1&gt;&lt;p&gt;在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第四篇-实践篇</title>
    <link href="http://example.com/2020/01/10/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E7%AF%87-%E5%AE%9E%E8%B7%B5%E7%AF%87/"/>
    <id>http://example.com/2020/01/10/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E7%AF%87-%E5%AE%9E%E8%B7%B5%E7%AF%87/</id>
    <published>2020-01-10T02:13:07.000Z</published>
    <updated>2023-02-07T03:08:41.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h1><ul><li>浏览器或POSTMAN或者curl命令行作为生产者提供消息；</li><li>SpringBoot提供消费者，将从Kafka拉取的消息打印出来；</li><li>命令行终端启动消费者打印出从Kafa拉取的消息</li></ul><h1 id="gradle引入Kafka及相关依赖"><a href="#gradle引入Kafka及相关依赖" class="headerlink" title="gradle引入Kafka及相关依赖"></a>gradle引入Kafka及相关依赖</h1><p>在<code>build.gradle</code>中引入相关jar包<br><code>org.springframework.kafka:spring-kafka</code>用于集成kafka；<br><code>com.google.code.gson:gson</code>用于格式化消息数据。  </p><pre><code>dependencies &#123;    compile(            &quot;org.springframework.boot:spring-boot-starter-web&quot;,            &quot;javax.servlet:jstl&quot;,            &quot;org.apache.tomcat.embed:tomcat-embed-jasper&quot;,            &quot;org.springframework.boot:spring-boot-starter-json&quot;,            &quot;org.springframework.kafka:spring-kafka&quot;,            &quot;com.google.code.gson:gson&quot;    )&#125;</code></pre><h1 id="application-yml添加kafka配置"><a href="#application-yml添加kafka配置" class="headerlink" title="application.yml添加kafka配置"></a>application.yml添加kafka配置</h1><pre><code>spring:    kafka:        producer:            bootstrap-servers: localhost:9092            key-serializer: org.apache.kafka.common.serialization.StringSerializer            value-serializer: org.apache.kafka.common.serialization.StringSerializer        consumer:            group-id: myGroup            key-deserializer: org.apache.kafka.common.serialization.StringDeserializer            value-deserializer: org.apache.kafka.common.serialization.StringDeserializer</code></pre><h1 id="创建消息实体"><a href="#创建消息实体" class="headerlink" title="创建消息实体"></a>创建消息实体</h1><pre><code>package com.shengsiyuan.boot.kafka;import java.util.Date;public class KafkaMessage &#123;    private long id;    private String username;    private String password;    private Date date;    public long getId() &#123;        return id;    &#125;    public void setId(long id) &#123;        this.id=id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username=username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password=password;    &#125;    public Date getDate() &#123;        return date;    &#125;    public void setDate(Date date) &#123;        this.date=date;    &#125;&#125;</code></pre><h1 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h1><pre><code>package com.shengsiyuan.boot.kafka;import com.google.gson.Gson;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.kafka.core.KafkaTemplate;import org.springframework.stereotype.Component;@Componentpublic class KafkaProducer &#123;    @Autowired    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;    public void sendMessage(KafkaMessage kafkaMessage)&#123;        System.out.println(&quot;sendMessage invoked!&quot;);        kafkaTemplate.send(&quot;myTopic&quot;, new Gson().toJson(kafkaMessage));    &#125;&#125;</code></pre><h1 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h1><pre><code>package com.shengsiyuan.boot.kafka;import org.apache.kafka.clients.consumer.ConsumerRecord;import org.springframework.kafka.annotation.KafkaListener;import org.springframework.stereotype.Component;@Componentpublic class KafkaConsumer &#123;    @KafkaListener(topics=&quot;myTopic&quot;, groupId=&quot;myGroup&quot;)    public void obtainMessage(ConsumerRecord&lt;String, String&gt; record)&#123;        System.out.println(&quot;Consumer obtains message!&quot;);        System.out.println(&quot;record topic: &quot; + record.topic());        System.out.println(&quot;record partition: &quot; + record.partition());        System.out.println(&quot;record key :&quot; + record.key());        System.out.println(&quot;record value: &quot; + record.value());        System.out.println(&quot;record offset:&quot; + record.offset());        System.out.println(&quot;record timestamp&quot; + record.timestamp());        System.out.println(&quot;record serializedKeySize: &quot; + record.serializedKeySize());        System.out.println(&quot;record serializedValueSize: &quot; + record.serializedValueSize());        System.out.println(&quot;=========================&quot;);    &#125;&#125;</code></pre><h1 id="创建Controller"><a href="#创建Controller" class="headerlink" title="创建Controller"></a>创建Controller</h1><pre><code>package com.shengsiyuan.boot.controller;import com.shengsiyuan.boot.kafka.KafkaMessage;import com.shengsiyuan.boot.kafka.KafkaProducer;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.Date;/*** @Program spring_lecture* @Title: KafkaController* @Description:* @Author: XueXiao* @Create: 2020-01-22 17:46:02*/@RestController@RequestMapping(value=&quot;/kafka&quot;)public class KafkaController &#123;    private static final Logger logger =LoggerFactory.getLogger(KafkaController.class);    @Autowired    private KafkaProducer kafkaProducer;    @RequestMapping(value=&quot;/get-msg&quot;, method=RequestMethod.GET)    public KafkaMessage sendMsg(@RequestParam(name=&quot;id&quot;) long id,                                @RequestParam(name=&quot;username&quot;) String username,                                @RequestParam(name=&quot;password&quot;) String password)&#123;        logger.info(&quot;sendMsg method is invoked!&quot;);        KafkaMessage kafkaMessage = new KafkaMessage();        kafkaMessage.setId(id);        kafkaMessage.setUsername(username);        kafkaMessage.setPassword(password);        kafkaMessage.setDate(new Date());        kafkaProducer.sendMessage(kafkaMessage);        return kafkaMessage;    &#125;    @RequestMapping(value=&quot;/post-msg&quot;, method=RequestMethod.POST)    public KafkaMessage sendMessage(@RequestBody KafkaMessage kafkaMessage)&#123;        logger.info(&quot;sendMessage method is invoked!&quot;);        kafkaMessage.setDate(new Date());        kafkaProducer.sendMessage(kafkaMessage);        return kafkaMessage;    &#125;&#125;</code></pre><h1 id="使用curl发送POST请求验证"><a href="#使用curl发送POST请求验证" class="headerlink" title="使用curl发送POST请求验证"></a>使用curl发送POST请求验证</h1><pre><code>curl -X POST -H &quot;Content-Type:application/json&quot; -d &#39;&#123;&quot;id&quot;:321,&quot;username&quot;:&quot;王五&quot;,&quot;password&quot;:&quot;123321&quot;&#125;&#39; http://localhost:9090/kafka/post-msg</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;浏览器或POSTMAN或者curl命令行作为生产者提供消息；&lt;/li&gt;
&lt;li&gt;SpringBoot提供消费者，</summary>
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="Kafka" scheme="http://example.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第三篇-理论进阶篇</title>
    <link href="http://example.com/2020/01/09/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E7%AF%87-%E7%90%86%E8%AE%BA%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <id>http://example.com/2020/01/09/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E7%AF%87-%E7%90%86%E8%AE%BA%E8%BF%9B%E9%98%B6%E7%AF%87/</id>
    <published>2020-01-09T02:07:31.000Z</published>
    <updated>2023-02-07T03:08:32.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于kafka分区"><a href="#关于kafka分区" class="headerlink" title="关于kafka分区"></a>关于kafka分区</h1><ul><li>每个分区都是一个有序、不可变的消息队列，后续新来的消息会源源不断地，持续追加到分区的后面，这相当于一种结构化的提交日志。</li><li>分区中的每一条消息都会被分配一个连续的id值（即offset）,该值用于唯一标识分区中的每一条消息。</li></ul><h1 id="分区的作用"><a href="#分区的作用" class="headerlink" title="分区的作用"></a>分区的作用</h1><ul><li>分区中的消息数据是存储在日志文件中的，而且同一分区中的消息数据是按照发送顺序严格有序的。分区在逻辑上对应一个日志，当生产者将消息写入分区中时，实际上是写到了分区所对应的日志当中。而日志可以看做是一种逻辑上的概念，它对应于磁盘上的一个目录。一个日志文件由多个Segment（段）来构成，每个Segment对应于一个索引文件与一个日志文件。</li><li>借助于分区，我们可以实现Kafka Server的水平扩展。对于一台机器来说，无论是物理机还是虚拟机，其运行能力总归是有上线的。当一台机器达到其能力上限时就无法再扩展了，即垂直扩展能力总是受到硬件制约的。通过使用分区，我们可以将一个主题中的消息分散到不同的Kafka Server上（这里需要使用Kafka集群），这样当期几点能力不足时，我们只需添加机器就可以了，在新的机器上创建新的分区，这样理论上就可以实现无限的水平扩展能力。</li><li>分区还可以实现并行处理能力，向一个主题所发送的消息会发送给该主题所拥有的不同的分区中，这样消息就可以实现并行发送与处理，由多个分区来接收所发送的消息。</li></ul><h1 id="Segment（段）"><a href="#Segment（段）" class="headerlink" title="Segment（段）"></a>Segment（段）</h1><p>一个partition是由一系列有序、不可变的消息所构成的。一个partition中的消息数量可能会非常多，因此显然不能将所有消息都保存到一个文件中。因此，类似于log4j的rolling log，当partition中的消息数量增长到一定程度后，消息文件会进行切割，新的消息会被写到一个新的文件当中，当新的文件增长到一定程度后，新的消息又会被写到另一个新的文件当中，以此类推；这一个个新的数据文件我们称之为Segment（段）。<br>因此，一个partition在物理上是由一个或者多个segment构成的。每个segment中则保存了真实的消息数据。</p><h1 id="partition与segment之间的关系"><a href="#partition与segment之间的关系" class="headerlink" title="partition与segment之间的关系"></a>partition与segment之间的关系</h1><ul><li>每个partition都相当于一个大型文件被分配到多个大小相等的segment数据文件中，每个segment中的消息数量未必相等（这与消息大小有着紧密的关系，不同的消息所占与的磁盘空间显然是不一样的），这个特点使得老的segment文件可以很容易就被删除掉，有助于提升磁盘的利用效率。</li><li>每个partition只需要支持顺序读写即可，segment文件的生命周期是由Kafka Server的配置参数决定的。比如说，server.properties文件中的参数项log.retention.hours&#x3D;168表示7天后删除老的消息文件。</li></ul><h1 id="关于分区目录中的4个文件的含义与作用"><a href="#关于分区目录中的4个文件的含义与作用" class="headerlink" title="关于分区目录中的4个文件的含义与作用"></a>关于分区目录中的4个文件的含义与作用</h1><ul><li>.index： 它是segment文件的索引文件，它与.log日志文件是成对出现的。后缀.index表示这是个索引文件。</li><li>.log： 它是segment文件的数据文件，用于存储实际的消息。该文件是二进制格式的。segment文件的命名规则是partition全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后条消息的offset值。没有数字则用0填充。若主题消息较少，则只有一个数据文件。</li><li>.timeindex： 该文件是一个基于消息日期的索引文件，主要用途是在一些根据日期或是时间来寻找消息的场景下使用，在基于时间的日志rolling或是基于基于时间的日至保留策略等情况下也会使用。实际上该文件是在Kafka较新的版本中才增加的，老版本Kafka是没有该文件的。它是对.index文件的一个有益补充。.index文件是基于偏移量的索引文件，而 *.timeindex则是基于时间戳的索引文件。</li><li>leader-epoch-checkpoint： 是leader的一个缓存文件。实际上，它是与Kafka的HW(High Water)和LEO(Log End Offset)相关的一个重要文件。</li></ul><h1 id="Kafka脚本重要命令"><a href="#Kafka脚本重要命令" class="headerlink" title="Kafka脚本重要命令"></a>Kafka脚本重要命令</h1><h2 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h2><pre><code>bin/kafka-topics.sh --create --zookeeper localhost;2181 --replication-factor 1 --partitions --topic myTopic</code></pre><h2 id="显示已有主题列表"><a href="#显示已有主题列表" class="headerlink" title="显示已有主题列表"></a>显示已有主题列表</h2><pre><code>bin/kafka-topics.sh –list –zookeeper localhost:218</code></pre><h2 id="查看某个主题详细信息"><a href="#查看某个主题详细信息" class="headerlink" title="查看某个主题详细信息"></a>查看某个主题详细信息</h2><pre><code>bin/kafka-topics.sh –describe –topic myTopic –zookeeper localhost 2181</code></pre><h2 id="开启生产者"><a href="#开启生产者" class="headerlink" title="开启生产者"></a>开启生产者</h2><pre><code>bin/kafka-console-producer.sh –broker-list localhost:9092 –topic myTopic</code></pre><h2 id="开启消费者"><a href="#开启消费者" class="headerlink" title="开启消费者"></a>开启消费者</h2><pre><code>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic myTopic –from beginning</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于kafka分区&quot;&gt;&lt;a href=&quot;#关于kafka分区&quot; class=&quot;headerlink&quot; title=&quot;关于kafka分区&quot;&gt;&lt;/a&gt;关于kafka分区&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;每个分区都是一个有序、不可变的消息队列，后续新来的消息会源源不断地，持续</summary>
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="Kafka" scheme="http://example.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第二篇-理论篇</title>
    <link href="http://example.com/2020/01/07/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%AF%87-%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    <id>http://example.com/2020/01/07/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%AF%87-%E7%90%86%E8%AE%BA%E7%AF%87/</id>
    <published>2020-01-07T01:43:36.000Z</published>
    <updated>2023-02-07T03:08:22.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h1><p>Kafka被用于构建实时的数据管道和流式app。它具备水平扩展性、容错性、速度快，且已运行在多家公司的生产环境中。<br>Kafka是一个分布式的流式平台。分布式流式平台具备三个关键能力：</p><ul><li>发布和订阅消息，类似于消息队列或企业消息传输系统</li><li>以容错的持久化方式存储消息</li><li>在消息发生时可以实时处理它们</li></ul><p>Kafka通常用于两大类应用：</p><ul><li>构建实时的流式数据管道，可以从系统和应用之间可靠地获取数据；</li><li>构建实时的流式应用，可以传输和响应数据流。</li></ul><p>几个概念：</p><ul><li>Kafka以集群的形式运行在一个或者多个服务器上，可以跨越多个数据中心。</li><li>Kafka集群以目录的形式存储消息，称之为主题。</li><li>每条记录包含key、value和时间戳。</li></ul><p>Kafka有四中核心API：</p><ul><li>Producer API允许应用发布消息到一个或者多个Kafka主题。</li><li>Consumer API允许订阅一个或者多个主题，并处理主题对其产生的消息。</li><li>Streams API允许应用作为一个流处理器，消费来自一个或多个主题的输入流，并产生输出流到一个或多个主题，有效的将输入流转换为输出流。</li><li>Connector API允许构建和运行可重用的生产者或消费者，将Kafka主题连接到现有的应用程序或数据系统。例如，关系型数据库的连接器将会捕获每张表的改变。</li></ul><p>在Kafka中，客户端与服务端之间的通讯是通过一个简单的、高性能的、语言无关的TCP协议完成。这个协议是版本化的，且能够向后兼容老版本。官方提供了Java客户端，但其实客户端可以使用其他语言。</p><h1 id="Topics-and-Logs-主题与日志"><a href="#Topics-and-Logs-主题与日志" class="headerlink" title="Topics and Logs(主题与日志)"></a>Topics and Logs(主题与日志)</h1><p>首先研究下Kafka为消息提供的核心抽象概念-主题(topic)。</p><p>主题是发布记录的类别或者源(feed)名称。Kafka中的主题总是多用户的；即主题可以有零个、一个或多个消费者来订阅写入其中的数据。</p><p>对每一个主题，kafka集群管理着一个如下的分区日志(partitioned log)：<br><img src="https://cdn.staticaly.com/gh/DoggieXue/Image-Home@master/log_anatomy.ssxvfwmgef4.jpg" alt="log_anatomy"></p><p>每个分区是一个有序的、不可变的记录序列，这个序列会持续的增加，形成一个结构化提交日志。分区中的每条记录被赋予一个称为偏移量(offset)的序列化ID值来唯一标识分区中的记录。</p><p>Kafka集群使用一个可配置的保留期来持久化所有发布的记录，无论该记录是否被消费。例如，如果保留策略被设置为两天，那么在记录发布后的两天内，他都是可以被用于消费的，两天后，将会被丢弃来释放空间。Kafka的性能是一个关于数据大小的有效常量，因此长时间存储数据不会有任何问题。<br><img src="https://cdn.staticaly.com/gh/DoggieXue/Image-Home@master/log_consumer.1w83ozu078f4.jpg" alt="log_consumer"></p><p>实际上，每个消费者唯一持有的元数据是消费者在日志中的偏移量或位置。该偏移量由消费者控制：通常，消费者会根据读取的记录线性地增加偏移量，但实际上，鉴于消费者控制这个位置，它可能以它喜欢的任何顺序消费记录。例如，消费者可以重置老的偏移量来重新处理以前的数据，或者跳过开头到最近的数据，并以此为起始位置开始消费。</p><p>这些特点的结合意味着Kafka的消费者是非常廉价的，它们的去或留不会对集群或其他消费者产生任何影响。例如，可以使用命令行工具’tail’任何主题的内容，而不会对已有的消费者产生任何影响。</p><p>日志中分区有几个用途。首先，他们允许日志扩展到超出单个服务器的大小。每个单独的分区必须适合持有它的服务器，但是一个主题可能包含多个分区，所以它可以处理任意数量的数据。其次，他们作为平行的单元，在这一点上可以做的更多。</p><h1 id="Distribution-分销"><a href="#Distribution-分销" class="headerlink" title="Distribution(分销)"></a>Distribution(分销)</h1><p>日志分区遍布Kafka集群的服务器中，每台服务器处理数据和共享分区的请求。每个分区被复制到可配置数量的服务器上用于容错。</p><p>每个分区都有一台服务器作为“leader”，零台或更多服务器作为“followrs”。leader为分区处理所有的读写请求，follower会被动的复制leader。如果leader挂了，其中的一个follower会自动成为leader。每台服务器会作为某些分区的leader和其他分区的follower，因此负载在集群中可以很好的被均衡。</p><h1 id="Producers-生产者"><a href="#Producers-生产者" class="headerlink" title="Producers(生产者)"></a>Producers(生产者)</h1><p>生产者将发布数据到其选择的主题。生产者负责选择发布哪条记录到主题下的哪个分区。这可以使用round-robin算法实现简单的负载均衡，或者通过语义分区函数实现。分区时通常使用第二种。</p><h1 id="Consumers-消费者"><a href="#Consumers-消费者" class="headerlink" title="Consumers(消费者)"></a>Consumers(消费者)</h1><p>消费者会在他们身上打上名为消费者组的标签，且每一条发布到主题的记录会被分发给订阅了消费者组中每一个的消费者实例。消费者实例可以运行在单独的进程中，也可以运行在单独的服务器上。</p><p>如果所有的消费者实例在相同的消费者组中，那么消息会被有效的负载均衡到每一个消费者实例上。</p><p>如果所有的消费者实例在不同的消费者组中，那么每一条记录将会被广播到所有的消费者进程中。<br><img src="https://cdn.staticaly.com/gh/DoggieXue/Image-Home@master/consumer-groups.2bz96uj8c0w0.jpg" alt="consumer-groups"></p><p>两个服务器的Kafka集群，拥有四个分区（P0-P4）和两个消费者组。消费者组A有两个消费者实例，消费者组B有四个消费者实例。</p><p>更常见的是，我们发现主题有少量的消费者组，每一个消费者组都有一个“逻辑订阅者”。每个消费者组由多个消费者实例组成，用于扩容和容错。这只不过是发布-订阅语义，其中订阅服务器是消费者集群，而不是单个进程。</p><p>Kafka中实现消费的方式是通过在消费者实例上划分日志中的分区，以便在任何时间点每一个实例是“公平共享”分区的专有消费者。这种维护组中成员资格的过程由Kafka协议动态处理。如果一个新的实例加入到组中，它会从组中其他成员那里分担一些分区；如果某个实例挂掉了，它的分区会被分发给其他活跃的实例。</p><p>Kafka只提供分区内记录的总顺序，而不提供主题中不同分区之间的总顺序。对于大部分应用来说，按分区排序和按键分区数据的能力已经足够了。然而，如果你需要记录总的顺序，可以通过只有一个分区的主题来实现，尽管这意味着每个消费者组只有一个消费者进程。</p><h1 id="Multi-tenancy"><a href="#Multi-tenancy" class="headerlink" title="Multi-tenancy"></a>Multi-tenancy</h1><p>可以将Kafka部署为多租户(Multi-tenancy)解决方案。Multi-tenancy可以通过配置哪个主题生产或者消费数据的方式来实现。还有对配额(quotas)的支持。管理员可以定义和强制请求上的配额来控制客户端使用的代理资源。</p><h1 id="Guarantee"><a href="#Guarantee" class="headerlink" title="Guarantee"></a>Guarantee</h1><p>高性能kafka给予以下保证：</p><ul><li>生产者发送消息到特定的主题分区，将会按照消息发送的顺序被追加。也就是说，如果消息M1和M2由同一个生产者发送，且M1先发送，那么M1的偏移量比M2小，且比M2更早的出现在日志中。</li><li>消费者实例按照日志中存储的顺序查看消息。</li><li>对于拥有N个副本的主题，最多容忍N-1个服务器故障，从而保证不会丢失任何提交到日志中的记录。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kafka简介&quot;&gt;&lt;a href=&quot;#Kafka简介&quot; class=&quot;headerlink&quot; title=&quot;Kafka简介&quot;&gt;&lt;/a&gt;Kafka简介&lt;/h1&gt;&lt;p&gt;Kafka被用于构建实时的数据管道和流式app。它具备水平扩展性、容错性、速度快，且已运行在多家公司</summary>
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="Kafka" scheme="http://example.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka学习第一篇-入门篇</title>
    <link href="http://example.com/2020/01/06/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://example.com/2020/01/06/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%85%A5%E9%97%A8%E7%AF%87/</id>
    <published>2020-01-06T09:20:31.000Z</published>
    <updated>2023-02-07T03:08:27.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p><a class="link"   href="https://kafka.apache.org/downloads" >官网下载Kafka<i class="fas fa-external-link-alt"></i></a> ,选择kafka_2.11-2.4.0.tgz下载<br>Kafka 严重依赖ZooKeeper，通过ZooKeeper管理各种数据和元数据，所以可以使用Kafka自带的ZooKeeper,也可以去<a class="link"   href="https://zookeeper.apache.org/" >Zookeeper官网下载<i class="fas fa-external-link-alt"></i></a><br>示例使用Kafka自带ZooKeeper。</p><h1 id="第一个示例"><a href="#第一个示例" class="headerlink" title="第一个示例"></a>第一个示例</h1><h2 id="Step-1-下载Kafka并解压"><a href="#Step-1-下载Kafka并解压" class="headerlink" title="Step 1: 下载Kafka并解压"></a>Step 1: 下载Kafka并解压</h2><pre><code>tar -xvf kafka_2.11-2.4.0.tgzcd kafka_2.11-2.4.0</code></pre><h2 id="Step-2-启动-Server"><a href="#Step-2-启动-Server" class="headerlink" title="Step 2:启动 Server"></a>Step 2:启动 Server</h2><p>启动ZooKeeper实例</p><pre><code>bin/zookeeper-server-start.sh config/zookeeper.properties</code></pre><p>出现以下信息表示ZooKeeper启动成功</p><pre><code>[2020-01-06 17:09:05,071] INFO binding to port 0.0.0.0/0.0.0.0:2181 (org.apache.zookeeper.server.NIOServerCnxnFactory)[2020-01-06 17:09:05,087] INFO zookeeper.snapshotSizeFactor = 0.33 (org.apache.zookeeper.server.ZKDatabase)[2020-01-06 17:09:05,089] INFO Snapshotting: 0x0 to /tmp/zookeeper/version-2/snapshot.0 (org.apache.zookeeper.server.persistence.FileTxnSnapLog)[2020-01-06 17:09:05,092] INFO Snapshotting: 0x0 to /tmp/zookeeper/version-2/snapshot.0 (org.apache.zookeeper.server.persistence.FileTxnSnapLog)[2020-01-06 17:09:05,112] INFO Using checkIntervalMs=60000 maxPerMinute=10000 (org.apache.zookeeper.server.ContainerManager)</code></pre><p>新建一个终端窗口，启动Kafka server</p><pre><code>bin/kafka-server-start.sh config/server.properties</code></pre><p>出现以下信息表示Kafka server启动成功</p><pre><code>[2020-01-06 17:15:19,195] INFO [SocketServer brokerId=0] Started data-plane processors for 1 acceptors (kafka.network.SocketServer)[2020-01-06 17:15:19,198] INFO Kafka version: 2.4.0 (org.apache.kafka.common.utils.AppInfoParser)[2020-01-06 17:15:19,198] INFO Kafka commitId: 77a89fcf8d7fa018 (org.apache.kafka.common.utils.AppInfoParser)[2020-01-06 17:15:19,198] INFO Kafka startTimeMs: 1578302119196 (org.apache.kafka.common.utils.AppInfoParser)[2020-01-06 17:15:19,200] INFO [KafkaServer id=0] started (kafka.server.KafkaServer)</code></pre><h2 id="Setp-3-创建主题"><a href="#Setp-3-创建主题" class="headerlink" title="Setp 3: 创建主题"></a>Setp 3: 创建主题</h2><p>新建一个终端窗口，创建一个只有一个分区和副本的名为”test”的主题（topic）</p><pre><code>bin/kafka-topics.sh --create --bootstrap-server localhost:9090 --replication-factor 1 --partitions 1 --topic test</code></pre><p>查看主题列表</p><pre><code>bin/kafka-topics.sh --list --bootstrap-server localhost:9092test</code></pre><p>表示主题创建成功！</p><h2 id="Setp-4-发送一些消息"><a href="#Setp-4-发送一些消息" class="headerlink" title="Setp 4: 发送一些消息"></a>Setp 4: 发送一些消息</h2><p>Kafka的命令行客户端将从一个文件或者标准输入获取输入信息，并将其作为消息发送给Kafka集群。默认情况下，每一行作为一个单独的消息发出。<br>新建生产者终端窗口：</p><pre><code>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test&gt;这是一个消息&gt;Hello World&gt;你好吗&gt;</code></pre><h2 id="Step-5-启动消费者"><a href="#Step-5-启动消费者" class="headerlink" title="Step 5: 启动消费者"></a>Step 5: 启动消费者</h2><p>Kafka也有一个命令行客户端，可以将消息展示到标准输出。<br>新建消费者终端窗口：</p><pre><code>bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning[2020-01-06 17:38:03,925] WARN [Consumer clientId=consumer-console-consumer-58504-1, groupId=console-consumer-58504] Connection to node 0 (/172.21.3.9:9092) could not be established. Broker may not be available. (org.apache.kafka.clients.NetworkClient)这是一个消息Hello World你好吗</code></pre><p>启动后，生产者发送到topic的消息会被拉取并显示。此时，切换到生产者终端窗口，继续输入消息，消息会被实时发送给消费者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软件安装&quot;&gt;&lt;a href=&quot;#软件安装&quot; class=&quot;headerlink&quot; title=&quot;软件安装&quot;&gt;&lt;/a&gt;软件安装&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://kafka.apache.org/downloads&quot; &gt;官</summary>
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="Kafka" scheme="http://example.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>使用非root用户停止和启动Apache、Nginx的方法</title>
    <link href="http://example.com/2019/12/31/%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%81%9C%E6%AD%A2%E5%92%8C%E5%90%AF%E5%8A%A8Apache%E3%80%81Nginx%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2019/12/31/%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%81%9C%E6%AD%A2%E5%92%8C%E5%90%AF%E5%8A%A8Apache%E3%80%81Nginx%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2019-12-31T06:18:38.000Z</published>
    <updated>2023-02-07T03:14:07.594Z</updated>
    
    <content type="html"><![CDATA[<p>Apache或Nginx运行时会监听80或者443端口，root权限被回收后，修改配置文件需要重启的情况下，可以通过给二进制文件set UID的方式实现。</p><h1 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h1><p>root用户登录进入到&#x2F;opt&#x2F;apache&#x2F;bin目录下</p><pre><code># cd /opt/apache/bin# chown root httpd# chmod u+s httpd# su - chatweb$ ll httpd -rwsr-xr-x 1 root chatweb 1546353 2017-08-14 httpd$ /opt/apache/bin/apachectl start</code></pre><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>root用户进入&#x2F;…&#x2F;nginx&#x2F;sbin目录下</p><pre><code># cd /.../nginx/sbin# chown root nginx# chmod u+s nginx# su - nginx$ ll nginx-rwsr-xr-x 1 root nginx 3289160 2019-05-05 nginx$ /.../nginx/sbin/nginx -s reload</code></pre><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Linux系统中的文件除了user id和group id外，还有俩称之为effective的id，四个id简写为uid、gid和euid、egid。<br>内核主要是根据euid和egid来确定进程对资源的访问权限：</p><ul><li>一个进程如果没有SUID或SGID位，则euid&#x3D;uid egid&#x3D;gid，分别是运行这个程序的用户的uid和gid；</li><li>如果一个程序设置了SUID，则euid和egid变成被运行的程序的所有者的uid和gid；</li><li>SUID的优先级比SGID高，当一个可执行程序设置了SUID，则SGID会自动变成相应的egid<br><code>set UID（SUID）</code>的作用是让执行该命令的用户以该命令拥有者的权限去执行。假如启动命令的拥有者是root用户，普通用户执行命令时就会拥有root的权限，然后使用root权限去操作服务。<br><code>set UID</code>的方式只针对二进制文件，是在执行程序（程序的可执行位被设置）时起作用，而可执行位只对普通文件和目录文件有意义。</li></ul><p>给文件加或去掉SUID和SGID的命令如下：</p><pre><code># chmod u+s filename 设置SUID位# chmod u-s filename 去掉SUID设置# chmod g+s filename 设置SGID位# chmod g-s filename 去掉SGID设置</code></pre><p>如果一个文件被设置了SUID或SGID位，会分别表现在所有者或同组用户的权限的可执行位上。例如：<br>1、-rwsr-xr-x 表示SUID和所有者权限中可执行位被设置<br>2、-rwSr–r– 表示SUID被设置，但所有者权限中可执行位没有被设置<br>3、-rwxr-sr-x 表示SGID和同组用户权限中可执行位被设置<br>4、-rw-r-Sr– 表示SGID被设置，但同组用户权限中可执行位没有被设置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Apache或Nginx运行时会监听80或者443端口，root权限被回收后，修改配置文件需要重启的情况下，可以通过给二进制文件set UID的方式实现。&lt;/p&gt;
&lt;h1 id=&quot;Apache&quot;&gt;&lt;a href=&quot;#Apache&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Java基础" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Nginx/OpenResty" scheme="http://example.com/tags/Nginx-OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统非root用户下安装Nginx</title>
    <link href="http://example.com/2019/04/28/Linux%E7%B3%BB%E7%BB%9F%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/"/>
    <id>http://example.com/2019/04/28/Linux%E7%B3%BB%E7%BB%9F%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/</id>
    <published>2019-04-28T03:41:38.000Z</published>
    <updated>2023-02-07T03:13:09.859Z</updated>
    
    <content type="html"><![CDATA[<p>通常使用Nginx或者Apache作为Web服务器时，默认监听80端口，因此默认会使用root用户去安装，而且，使用yum命令安装时，通常会安装到默认的路径下，默认路径通常是root用户才有执行权限的。如果不需要使用Nginx监听1024以下的端口，且对权限和网络管理比较严格时，能用非root权限解决的，就用普通用户。在此使用编译Nginx源码的方式安装Nginx。 假设已拿到root用户权限，但需要使用普通用户去管理Nginx。</p><h1 id="登录Linux服务器"><a href="#登录Linux服务器" class="headerlink" title="登录Linux服务器"></a>登录Linux服务器</h1><pre><code>root登录服务器ssh root@x.x.x.x</code></pre><h1 id="创建普通用户并设置密码"><a href="#创建普通用户并设置密码" class="headerlink" title="创建普通用户并设置密码"></a>创建普通用户并设置密码</h1><p>创建普通用户</p><pre><code># useradd nginx</code></pre><p>为nginx用户设置密码为nginx#123</p><pre><code># echo nginx#123|passwd --stdin nginx</code></pre><p>创建完毕用户后，切换到nginx用户</p><pre><code># su nginx</code></pre><p>进入用户目录</p><pre><code>$ cd ~</code></pre><h1 id="安装openssl"><a href="#安装openssl" class="headerlink" title="安装openssl"></a>安装openssl</h1><p>下载地址：<a class="link"   href="https://www.openssl.org/source/" >https://www.openssl.org/source/<i class="fas fa-external-link-alt"></i></a></p><p>进入用户目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf openssl$ rm -rf openssl-1.1.0j #（以机器上实际安装的为准）</code></pre><p>解压</p><pre><code>$ tar -zxv -f openssl-1.1.0j.tar.gz</code></pre><p>进入源码目录</p><pre><code>$ cd openssl-1.1.0j</code></pre><p>配置<br>注意，prefix和opensslsir的值要写绝对路径，不能是相对路径，表示编译后的地址</p><pre><code>$ ./config --prefix=/home/nginx/openssl --openssldir=/home/nginx/openssl/conf</code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><p>检查安装</p><pre><code>$ cd /home/nginx/openssl/bin$ openssl version -a</code></pre><h1 id="安装pcre"><a href="#安装pcre" class="headerlink" title="安装pcre"></a>安装pcre</h1><p>下载地址：<a class="link"   href="https://sourceforge.net/projects/pcre/" >https://sourceforge.net/projects/pcre/<i class="fas fa-external-link-alt"></i></a></p><p>进入安装目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf pcre$ rm -rf pcre-8.43 （以机器上实际安装的为准）</code></pre><p>解压</p><pre><code>$ tar -zxv -f pcre-8.43.tar.gz</code></pre><p>进入源码目录</p><pre><code>$ cd pcre-8.43</code></pre><p>执行配置</p><pre><code>$./configure --prefix=/home/nginx/pcre/</code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><h1 id="安装zlib"><a href="#安装zlib" class="headerlink" title="安装zlib"></a>安装zlib</h1><p>下载地址：<a class="link"   href="http://zlib.net/" >http://zlib.net/<i class="fas fa-external-link-alt"></i></a></p><p>进入安装目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf zlib$ rm -rf zlib-1.2.11（以机器上实际安装的为准）</code></pre><p>解压</p><pre><code>$ tar -zxv -f zlib-1.2.11.tar.gz</code></pre><p>进入源码目录</p><pre><code>$ cd zlib-1.2.11</code></pre><p>配置</p><pre><code>$./configure --prefix=/home/nginx/zlib/</code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><p>下载地址：<a class="link"   href="http://nginx.org/en/download.html" >http://nginx.org/en/download.html<i class="fas fa-external-link-alt"></i></a></p><p>进入安装目录</p><pre><code>$ cd ~</code></pre><p>删除原有安装（如果有的话）</p><pre><code>$ rm -rf nginx$ rm -rf nginx-1.14.2</code></pre><p>解压</p><pre><code>$ tar -zxvf nginx-1.14.2.tar.gz</code></pre><p>进入安装目录</p><pre><code>$ cd nginx-1.14.2</code></pre><p>配置(使用openssl、pcre、zlib的源码路径)</p><pre><code>$ ./configure \--user=nginx \--group=nginx \--prefix=/home/nignx/nginx \--with-http_ssl_module \--with-openssl=/home/nignx/openssl-1.1.0j \--with-pcre=/home/nignx/pcre-8.43 \--with-zlib=/home/nignx/zlib-1.2.11 \--with-http_stub_status_module \--with-threads</code></pre><p>编译安装</p><pre><code>$ make &amp;&amp; make install</code></pre><p>修改监听端口为非1024</p><pre><code>$ vi ~/nginx/conf/nginx.confserver &#123;    listen      8089;    server_name localhost;    location &#123;        root    html;        index   index.html  index.htm;    &#125;&#125;</code></pre><p>验证</p><pre><code>$ /home/nginx/nginx/sbin/nginx -Vnginx version: nginx/1.14.2built by gcc 4.4.7 20120313 (Red Hat 4.4.7-11) (GCC) built with OpenSSL 1.1.0j  20 Nov 2018TLS SNI support enabledconfigure arguments: --user=nginx --group=nginx --prefix=/home/nginx/nginx --with-http_ssl_module --with-openssl=/home/nginx/openssl-1.1.0j --with-pcre=/home/nginx/pcre-8.43 --with-zlib=/home/nginx/zlib-1.2.11 --with-http_stub_status_module --with-threads</code></pre><h1 id="启动、重启、停止"><a href="#启动、重启、停止" class="headerlink" title="启动、重启、停止"></a>启动、重启、停止</h1><p>启动</p><pre><code>$ /home/nginx/nginx/sbin/nginx</code></pre><p>重启</p><pre><code>$ /home/nginx/nginx/sbin/nginx -s reload</code></pre><p>停止</p><p>查询nginx主进程号</p><pre><code>$ ps -ef | grep nginx</code></pre><p>停止进程</p><pre><code>$ kill -QUIT 主进程号</code></pre><p>快速停止</p><pre><code>$ kill -TERM 主进程号</code></pre><p>强制停止</p><pre><code>$ pkill -9 nginx</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试端口</p><pre><code>$ netstat –na|grep 8089</code></pre><p>浏览器中测试</p><pre><code>$ curl localhost:8089</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通常使用Nginx或者Apache作为Web服务器时，默认监听80端口，因此默认会使用root用户去安装，而且，使用yum命令安装时，通常会安装到默认的路径下，默认路径通常是root用户才有执行权限的。如果不需要使用Nginx监听1024以下的端口，且对权限和网络管理比较严</summary>
      
    
    
    
    <category term="Nginx" scheme="http://example.com/categories/Nginx/"/>
    
    
    <category term="Nginx/OpenResty" scheme="http://example.com/tags/Nginx-OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>Item-18 组合优于继承</title>
    <link href="http://example.com/2019/02/26/%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF/"/>
    <id>http://example.com/2019/02/26/%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF/</id>
    <published>2019-02-26T10:18:28.000Z</published>
    <updated>2023-02-07T03:06:20.545Z</updated>
    
    <content type="html"><![CDATA[<p>继承是实现代码复用的有效方式，但对于工作来说它并不总是最好的工具。使用不当就会导致脆弱的软件系统。在同一个包中使用继承是安全的，在这里子类和父类在同一个程序员的控制下。继承特殊设计且注释了扩展的类也是安全的（Item 19）。然而，跨包继承普通的抽象类是危险的。作为一个提示，本书使用“继承”一词来表示实现继承（一个类扩展另一个类）。在本条款中讨论的问题不适合接口继承（一个类实现了一个接口或者一个接口继承了另一个）。<br>  与方法调用不同的是，继承会破坏封装。换句话说，子类的某些适当的功能依赖于其父类的实现细节。父类的实现会随着版本的发布而改变，若已经改变了，会破坏子类。即使其代码从未被动过。因此，子类必须与父类一起更新，除非父类的作者为了扩展为了扩展而专门设计并记录的它。<br>  为了更具体，假设我们有一个使用了HashSet的程序。为调整我们程序的性能，我们需要查询HashSet自创建以来添加过多少元素（不要与其当前的大小混淆，当前的大小会随着元素的移除而变小）。为提供此功能，我们定义一个HashSet变量来记录试图插入元素的数量并且为该数量暴露访问权限。HashSet类包含两个具备插入元素能力的方法：add和addAll，因此我们要重写这些方法：</p><pre><code>//Broken - Inappropriate use of inheitance !public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; &#123;    private int addCount = 0;    public InstrumentedHashSet() &#123;    &#125;    public InstrumentedHashSet(int initCap, float loadFactor) &#123;        super(initCap, loadFactor);    &#125;    @Override    public boolean add(E e) &#123;        addCount++;        return super.add(e);    &#125;    @Override    pubic boolean addAll(Collection&lt;? extends E&gt; c) &#123;        addCount += c.size();        return super.addAll(c);    &#125;    public int getAddCount() &#123;        return addCount;    &#125;&#125;</code></pre><p>  这个类看起来使合理的，但是不起作用。假设我们创建了一个实例，并且使用addAll方法添加了三个元素。顺便说一下，请注意我们使用在Java 9 中加入的静态工厂方法List.of创建了一个列表，若用的是更早的JDK发行版，使用Arrays.asList方法替代：</p><pre><code>InstrumentedHashSet&lt;String&gt; s = new InstrumentedHashSet&lt;&gt;();s.addAll(List.of(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;));</code></pre><p>  我们期望getAddCount方法此时返回三个，但是它返回了六个。发生了什么错误？在内部，HashSet的addAll方法是在add的基础上实现的，即使HashSet十分合理，但它没有记录这个实现细节。InstrumentedHashSet中的addAll方法添加了三个到addCount上，然后调用使用super.addAll调用了HashSet的addALl实现。这又反过来对每一个元素调用add方法，因为在InstrumentedHashSet中重写了它。这三次调用中的每一个都会添加一到addCount上，所以总共增加了六：使用addAll方法每添加一个元素都会重复计算。<br>  我们可以通过消除对addAll方法的重写来“修复”子类。尽管生成的类可以工作，但它取决于HashSet的addAll方法是否在其add方法之上实现正确功能。这种“自用（self-use）”是一个实现细节，不保证在所有的Java平台中都持有，且不会随着版本的发行而改变。因此，生成的InstrumentedHashSet类是脆弱的。<br>  重写addAll方法时，迭代特定的集合，为每一个元素调用一次add方法会更好一点。这会导致正确的结果，无论addAll方法是否在add方法之上实现，因为HashSet的addAll方法将不再被调用。然而这个技巧不会解决我们所有的问题。它相当于重新实现了那些可能会或者可能不会导致自用的父类方法，这些方法很难、耗时、容易出错且会降低性能。另外，这也是不可能的，因为一些方法不可能在无法访问子类无法访问的私有变量时实现。<br>  导致子类脆弱的一个相关原因是其父类可能在后续的发行版本中获得一个新的方法。假设一个程序的安全性取决于所有插入集合的元素满足某些谓词。这可以通过继承集合并且重写每一个具备添加元素能力的方法，来确保在添加元素前，满足这些谓词。这会一直生效，知道一个新的具备添加元素能力的方法在后续的发行版本中被添加到父类中。一旦这种情况发生了，仅通过调用这个未在子类中重写的新方法可能会添加一个“非法”元素。这不是一个纯粹的理论问题。当HashSet和Vector被重新加入集合框架时，该现象导致的安全漏洞必须被修复。<br>  以上两个问题都源于重写方法。也许你会认为继承一个类如果只是添加新方法并且避免重写已存在的方法是安全的。尽管这种扩展更安全，但它不是没有风险。如果父类在后续的发行版本中获得了一个新方法，很不幸的是你在子类中定义了一个签名相同且返回类型不同的方法，这时子类将不会编译通过[JLS, 8.4.8.3]。如果你在子类中定义了签名相同且返回类型与父类中新增的方法相同，那么你现在正在重写它，所以你会遭遇之前描述的问题。而且你的方法是否满足新父类方法的规范还是充满疑问的，因为这些规范在你定义子类方法时还没有定义。<br>  幸运的是，有一种方式可以避免上面描述的所有问题。给新的类定义一个私有的引用了已存在类的成员变量，来替代继承该类的方式。这种设计被称作组合，因为已存在类变成了新类的一个组件。新类的每一个实例调用已存在类中包含的相应的方法并且返回结果。这被称作转发，并且新类中的方法被称作转发方法。新生成的类将坚如磐石，不依赖于存在类的实现细节。即使在已存在类中添加新方法也不会影响新类。为了更具体的说明，这里有一个InstrumentedHashSet的替代，它使用了组合-转发（composition-and-forwarding）的方式。请注意，实现被分成了两部分：类本身和复用转发类，其中转发类包含所有的转发方法再没有其他的。</p><pre><code>//Wrapper class - use composition in place of inheritancepublic class InstrumentedHashSet&lt;E&gt; extends ForwardingSet&lt;E&gt; &#123;    private int addCount = 0;    public InstrumentedHashSet(Set&lt;E&gt; s) &#123;        super(s);    &#125;    @Override     public boolean add(E e) &#123;        addCount++;        return super.add(e);    &#125;    @Override     public boolean addAll(Collection&lt;? extends E&gt; c) &#123;         addCount += c.size();        return super.addAll(c);    &#125;    public int getAddCount() &#123;        return addCount;    &#125;&#125;// Reusable forwarding classpublic class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; &#123;    private final Set&lt;E&gt; s;    public ForwardingSet(Set&lt;E&gt; s) &#123; this.s = s; &#125;    public void clear()               &#123; s.clear();            &#125;    public boolean contains(Object o) &#123; return s.contains(o); &#125;    public boolean isEmpty()    public int size()    public Iterator&lt;E&gt; iterator()    public boolean add(E e)    public boolean remove(Object o)    public boolean containsAll(Collection&lt;?&gt; c) &#123;         return s.containsAll(c);     &#125;    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;         return s.addAll(c);    &#125;    public boolean removeAll(Collection&lt;?&gt; c) &#123;         return s.removeAll(c);    &#125;    public boolean retainAll(Collection&lt;?&gt; c) &#123;     return s.retainAll(c);    &#125;    public Object[] toArray() &#123;         return s.toArray();      &#125;    public &lt;T&gt; T[] toArray(T[] a) &#123;        return s.toArray(a);     &#125;    @Override     public boolean equals(Object o) &#123;         return s.equals(o);      &#125;    @Override public int hashCode() &#123;        return s.hashCode();     &#125;    @Override public String toString() &#123;         return s.toString();     &#125;&#125;</code></pre><p>  InstrumentedSet类的设计基于现有的Set的接口，该接口包含HashSet类的一些功能方法。除了健壮以外，这个设计十分的灵活。InstrumentedSet类实现了Set方法，且包含一个单独的构造方法，其参数是一个Set类型。在本质上，该类将一个Set转化为另一个，添加了检测功能。不像基于继承的方式，只为某个具体类生效，并且需要为父类中每一个支持的构造函数提供单独的构造函数，包装类可用于检测任何Set实现，并且可与任何预先存在的构造函数一起使用：</p><pre><code>Set&lt;Instant&gt; times = new InstrumentedSet(new TreeSet&lt;&gt;(cmp));Set&lt;E&gt; s = new InstrumentedSet&lt;&gt;(new HashSet&lt;&gt;(INIT_CAPACITY));</code></pre><p>InstrumentedSet类甚至可以临时用于原本就没有设计特性的Set实例：</p><pre><code>static void walk(Set&lt;Dog&gt; dogs) &#123;InstrumentedSet&lt;Dog&gt; iDogs = new InstrumentedSet&lt;&gt;(dogs);... // Within this method use iDogs instead of dogs&#125;  </code></pre><p>  InstrumentedSet类被称作包装类，因为每一个InstrumentedSet实例包含（“包装”）了另一个Set实例。这也被称作装饰模式【Gamma95】,因为InstrumentedSet类通过添加一个计数说明“装饰”了一个set实例。有时，组合和转发放在一起被简单的称作代理。从技术角度讲，这并不是代理，除非包装者对象（wrapper object）将其自身传给被包装（wrapped object）对象[Lieberman86; Gamma95]。<br>  包装类的缺点很少。唯一需要注意的是包装类不适合在回调框架中使用，在这类框架中，对象为了一系列的调用将自身引用传递给另一个对象。因为一个被包装对象其包装对象，它传递了一个自身的引用（this）并且回调时避开了包装者。这被称作SELF问题【Lieberman86】。有些人会担心转发方法调用的性能影响或者包装对象的内存占用影响。以上两者在实践中证明没有太大的影响。编写转发方法很繁琐，但你必须为每个接口编写一次可重用的转发类，并且可能已经为你提供了转发类。例如，Guava为每一个集合接口提供了转发类【Guava】。<br>  继承只有在子类确实是父类子类型这种特定情况下适合。换句话说，类B和类A之间存在“B是A”的关系时，类B才应该继承类A。如果你试图让类B继承类A，自问以下问题：每一个B确实真的是A吗？如果你不能真正的对这个问题回答是，B就不应该继承A。如果答案是否定的，那通常是B包含一个A的私有的成员变量并且暴露了一个不同的API的情况：A不是B点必要部分，仅是B的实现细节。<br>  在Java类库中有许多明显的违背该规则的地方。例如，栈不是向量，因此Stack不应该继承Vector。同样的，属性集合不是哈希表，因此Properties不应该继承HashTable。对于以上两种情况，使用组合会更合适。<br>  如果你在适合使用组合的地方使用继承，那么就不需要暴露实现细节。生成的API将你与原始实现联系起来，永远限制了你编写类的性能。更严重的是。会直接暴露你想让客户端访问的内部变量。至少，它会导致语义混乱。例如,p是Properties实例的引用，那么p.getProperty(key)与p.get(key)将会产生不用的结果：前面的方法考虑获取默认值，后面的方法继承自HashTable却不会这么做。更严重的是，客户端可以通过直接修改父类来修改子类的不变量。在Properties例子中，设计者希望只有字符串允许作为键和值，但是直接访问底层的HashTable会破坏不变量。一旦不变量被破坏，将不可能再使用Properties的其他API（load和store）了。当该问题被发现时，再修复它已经为时过晚，因为客户端已经依赖于非字符串的键值在使用了。<br>  在决定使用继承替代组合前，有一系列的问题需要自问下。你考虑继承的类在其API中是否存在任何缺陷？如果存在，你是否愿意将这些缺陷传播到你自己类的API中？继承会把父类中的任何缺陷进行传播，但是会让你设计一个新的API来避免这些缺陷。<br>  总的来说，继承是强大的，但也是有问题的，因为它会破坏封装。只有在子类和父类之间存在真正的子类型关系时才适用。即使存在这种关系，继承会因子类与父类不在同一个包中，且父类没有专门为继承而设计而导致脆弱性。为避免这种脆弱性，使用组合和转发来代替继承，特别是存在实现了包装类的适当的接口，包装类不仅比子类更健壮，而且功能更强大。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;继承是实现代码复用的有效方式，但对于工作来说它并不总是最好的工具。使用不当就会导致脆弱的软件系统。在同一个包中使用继承是安全的，在这里子类和父类在同一个程序员的控制下。继承特殊设计且注释了扩展的类也是安全的（Item 19）。然而，跨包继承普通的抽象类是危险的。作为一个提示</summary>
      
    
    
    
    <category term="Java基础" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Effective Java 3rd" scheme="http://example.com/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-17 使可变性最小化</title>
    <link href="http://example.com/2019/02/25/%E4%BD%BF%E5%8F%AF%E5%8F%98%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96/"/>
    <id>http://example.com/2019/02/25/%E4%BD%BF%E5%8F%AF%E5%8F%98%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96/</id>
    <published>2019-02-25T10:15:32.000Z</published>
    <updated>2023-02-07T03:07:23.023Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，不可变类是一种实例不能被修改的类。其每个实例包含的信息在对象的整个生命中期中是固定的，因此在这个过程中观察不到任何改变。Java平台类库包含很多不可变类，包括String、包装原生类、BigInteger和BigDecimal。这么做有许多好处：不可变类比可变类更易于设计、实现和使用。他们更少出错并且更安全。</p><p>  让一个类不可变，要遵循以下五条规则：</p><ul><li>禁止提供修改对象状态的方法（比如存取器mutators，即setter方法）。</li><li>确保该类不能被扩展。这会阻止粗心或恶意子类通过改变对象的状态来破坏类的不可变行为。为防止类被继承（子类化），通常是将类定义为final的，但还有另一种方式，我们后面讨论。</li><li>将所有字段定义成final的。这可以清楚地以系统强制的方式表达我们的意图。而且，必须确保新创建实例的引用在缺乏同步机制的情况下,被从一个线程传递给另一个线程时的正确行为，正如在内存模型中阐述的那样【JLS, 17.5; Goetz06, 16】。</li><li>将所有字段定义成私有的。这可以防止客户端获取被字段引用的可变对象的访问权，并且直接修改这些对象。虽然技术上允许不可变类的公共的终态的子弹包含原生值或不可变对象引用，但不建议这么做，因为它会妨碍了在后续发行版本中修改类的内部表示。</li><li>确保对任何可变组件的互斥访问。如果类里包含任何可变对象的引用，则要确保类的客户端不能获取指向这些对象引用。永远不要用客户端提供的对象引用来初始化这些字段或者从访问方法中返回这个字段的引用。在构造方法、访问器和readObject方法中（Item 50）请使用保护性拷贝（Item 80）。</li></ul><p>  在之前条款中的许多示例类都是不可变的。其中一个是条款11中的PhoneNumber，它的每一个属性都有访问方法，但是没有相应的设置方法。下面是一个稍微复杂点的例子：</p><pre><code>// Immutable complex number class public final class Complex &#123;     private final double re;     private final double im;    public Complex(double re, double im) &#123;        this.re = re;        this.im = im;    &#125;    public double realPart() &#123;        return re;     &#125;    public double imaginaryPart() &#123;         return im;     &#125;    public Complex plus(Complex c) &#123;        return new Complex(re + c.re, im + c.im);    &#125;    public Complex minus(Complex c) &#123;        return new Complex(re - c.re, im - c.im);    &#125;    public Complex times(Complex c) &#123;        return new Complex(re * c.re - im * c.im,                        re * c.im + im * c.re);    &#125;    public Complex dividedBy(Complex c) &#123;        double tmp = c.re * c.re + c.im * c.im;        return new Complex((re * c.re + im * c.im) / tmp,                        (im * c.re - re * c.im) / tmp);    &#125;    @Override     public boolean equals(Object o) &#123;        if (o == this)            return true;        if (!(o instanceof Complex))            return false;        Complex c = (Complex) o;        // See page 47 to find out why we use compare instead of == return Double.compare(c.re, re) == 0            &amp;&amp; Double.compare(c.im, im) == 0;        &#125;        @Override public int hashCode() &#123;            return 31 * Double.hashCode(re) + Double.hashCode(im);        &#125;        @Override public String toString() &#123;            return &quot;(&quot; + re + &quot; + &quot; + im + &quot;i)&quot;;    &#125; &#125;</code></pre><p>  这个类表示一个复数（y一个包含了实数部分和虚数部分的数字）。除了标准Object方法，它为实数部分和虚数部分部分提供了访问方法，并且提供了四个基本的数学运算：加法、减法、乘法和除法。注意基本运算如何创建的，以及为什么返回一个新的Complex实例，而不是修改原有的实例。这种模式被称作函数是方法（functional approache），因为方法返回应用函数在其操作数上得出的结果，而没有修改这个操作数。与之相应的是程序方法或命令方法，这两种方法都将一个过程应用于操作数，从而导致操作数的状态发生变化。注意方法名称是介词(如plus)而不是动词（如add）。这强调了方法不会改变对象值的事实。BigInteger和BigDecimal类不遵循该命名规范，并且它导致了许多使用错误。<br>  如果你对函数式方法不熟悉，可能会觉得它有点不自然，但它（可以让传进来的参数）具有不可变性，这就具有许多优点。不可变对象能让很多情况简单化。不可变对象可以保持一个状态，即创建它的状态。如果确保所有构造函数都建立了类不变量（invariants，约束关系），那么可以保证这些不变量始终有效，就无需你或者使用这个类的程序员做额外的工作。另一方面，可变对象可以拥有任意复杂的状态空间。如果文档没有提供修改方法会造成对象状态转移的精确描述，则可能很难或者不可能放心的使用可变类。<br>  不可变类本质上（天生的）就是线程安全的，它们不需要同步。他们不会被多线程并发访问所破坏。这是实现线程安全最简单的方法。既然没有线程可以观察到另一个线程对不可变对象的任何影响，那么不可变对象可以被自由地共享。因此，不可变类应该鼓励客户端在任何可能的地方复用现有实例。其中一种简单的方式是为常用值提供共有静态且终态的常量值。例如，Complex类提供如下常量：</p><pre><code>public static final Complex ZERO = new Complex(0, 0);public static final Complex ONE  = new Complex(1, 0);public static final Complex I    = new Complex(0, 1);</code></pre><p>  这种方式可以更进一步扩展。不可变类可以提供静态工厂来缓存频繁请求的实例，避免重复创建现有实例。所有的包装原生类和BigInteger都采用了这种方式。使用这些静态工厂导致客户端共享实例而不是每次创建新实例，还会减少内存占用和垃圾回收的消耗。在设计一个新类时，选择静态工厂代替共有构造方法，可以让你在今后灵活地添加缓存，而不需要修改客户端。<br>  不可变对象可以自由地被共享这一事实的好处（consequence）是，你永远不能为他们做防御性拷贝（Item 50）。事实上，你根本就不用做任何拷贝，因为拷贝结果将永远等于原对象。因此，你不需要也不应该为不可变类提供clone方法或者（用于）复制的构造函数（Item 13）。在Java平台的早期阶段，这一点不是很好理解，因此String类提供了一个（用于复制）的构造方法，但它应该尽量少用。<br>  不仅可以共享不可变对象，还可以共享它们的内部信息。例如，BigInteger类在内部使用一个符号-数值表示。符号使用一个int值来表示，数值使用int数组来表示。其negate方法产生一个数值相同、符号x相反的新的BigInteger。虽然数组是可变的，（这个方法）也不需要复制数组；新创建的BigInteger指向原始实例的同一个内部数组。<br>  不可变对象为其他对象提供了很多的构建快，无论（其他对象）是可变的还是不可变的。如果你知道complex对象的内部组件（component object）不会发生变化，那么就很容易维护它的不变性(invariants)。该规则的一个特例是：不可变对象可以创建大量的map键和set集合元素：一旦它们成了map的键或set集合元素，也不用担心它们的值发生变化，虽然这会破坏map或set的不变性。<br>  不可变对象提供了免费的失败原子机制（Item 76）。它们的状态永远不会改变，因此，不可能出现临时不一致性。<br>  不可变对象的最大缺点是对每一个不同的值都需要一个对应的对象。创建这些对象花销会很大，尤其是大型对象。例如，假设你有一个上百万位的BigInteger，并且你想要更改其低位：</p><pre><code>BigInteger moby = ...;moby = moby.flipBit(0);</code></pre><p>flipBit方法创建一个新的BigInteger实例，也有百万位的长度，它只有一位与原对象不同。该操作需要的时间与空间与BigInteger大小成正比。将此与java.util.BitSet对比。像BigInteger一样的是，BitSet表示一个任意长的位，但跟BigInteger不一样的是，BitSet是可变的。BitSet类提供了一个方法，允许你在常量时间内修改一个上百万位实例的其中某一位的状态：</p><pre><code>BitSet moby = ...;moby.flip(0);</code></pre><p>  如果你执行一个多步操作并且每一步操作都会生成一个新的对象，同事丢弃除最终结果意外的其余对象，那么性能问题将会被放大。有两种方式可以解决这个问题。第一个是猜测哪些多步操作会经常遇到，并将它们作为基本类型提供。如果以基本类型的方式提供多步操作，那么不可变对象就不用在每一步创建一个对应的对象。在内部，不可变类可以灵活变动。例如，BigInteger包含一个包级私有的“伴生类”，它可以用于加速诸如模幂运算（modular exponentiation.）的多步操作。基于前面概述的所有原因，使用可变的伴生类比使用BigInteger更难。幸运的是你不需要使用（这个伴生类），因为BigInteger的实现者已经为你做了这项艰难的工作。<br>  如果你能准确预测到客户端将在不可变类上执行哪些复杂操作，那么包级别私有的可变伴生类方式将会运行的很好。如果不能准确预测，那最好的选择是提供一个共有的可变伴生类。该方式的主要示例是Java平台类库中的String类，它的半生类是StringBuilder（以及快废弃不用的StringBuffer）。<br>  既然你知道如何创建一个不可变类并且了解不变性的利弊，下面让我们讨论几个设计方案。回想一下，为保证不变性，一个类不得允许自己被子类化。这可以通过将类定义成final的来实现，但有另一种更灵活的选择。除了将不可变类定义成final的，可以将它所有的构造方法定义成私有的或者包级私有的，并且添加公共静态工厂替代公共构造方法（Item 1）。为了具体说明这一点，下面是Complex类采用这种方式的实现：</p><pre><code>//Immutable class with static factories instead of constructorspublic class Complex &#123;    private final double re;    private final double im;    private Complex(double re, double im) &#123;         this.re = re;        this.im = im;    &#125;    public static Complex valueOf(double re, double im) &#123;         return new Complex(re, im);    &#125;... // Remainder unchanged&#125;</code></pre><p>  这种方式通常是最好的选择。它是最灵活的，因为它允许使用多个包级私有的实现类。对于包以外的客户端来说，不可变类实际上是终态的，因为它不可能扩展一个来自其他包并且缺少公共或者受保护的构造方法的类。除了允许多个实现类的灵活性外，该方式还可能在未来发行版本中通过提高静态工厂的对象缓存能力来改善类的性能。<br>  当初在编BigInteger和BigDecimal时，不可变类必须必须是终态的并不被广泛地理解，所以他们的所有方法都可以被重写。不幸的是，在保留向后兼容时，这无法得到修改正。如果你编写了一个类，其安全性取决于来自不可信客户端上送的BigInteger或BigDecimal参数的不变性，那么你必须检查下参数是不是“真的”BigInteger或者BigDecimal，而不是不可信子类的实例。如果它是后者，你必须假设它是可变的，并进行防御性拷贝（Item 50）：</p><pre><code>public static BigInteger safeInstance(BigInteger val) &#123;    return val.getClass() == BigInteger.class ? val : new BigInteger(val.toByteArray());&#125;</code></pre><p>  该条款开始时列出的不可变类的规则表明，没有方法可以修改对象并且其所有字段必须是终态的。事实上，这些规则比（实际需求）要强硬一些，可以（适当）放宽以提高性能。事实是没有任何方法会对对象的状态产生外部可见的变化。然而，一些不可变类会在首次需要的时候，将一些复杂计算的结果缓存到一个或更多的非终态变。如果相同的值被再次请求，将会返回缓存值，来节约重新计算的花销。这个技巧正是因为对象是不可变的，所以在重复计算时会产生相同的结果。<br>  例如，PhoneNumber的hashCode方法，在首次调用时计算哈希码并缓存它，一旦再次调用就返回缓存值。这个技巧是懒加载&#x2F;延迟加载（Item 83）的一个示例，也被String使用。<br>  应该添加一个有关于序列化的警告。如果你选择使你的不可变类实现Serializable接口，且它包含一个或者多个指向可变对象的字段，即使默认的序列化形式是可被接受的，你必须提供一个显式的readObject或者readResolve方法，或者使用ObjectOutputStream.writeUnshared或者ObjectInputStream.readUnshared方法。否则攻击者就会对你的类创建一个可变实例。条款88中详尽地介绍了该主题。<br>  总而言之，要抵制为每一个getter方法写一个setter方法的冲动。类应该是不可变的，除非有一个很好的理由使他们可变。不可变类提供许多优点，他们的唯一缺点是在某些情况下出现的性能问题。应该总是将值小的对象定义成不可变的，例如PhoneNumber和Complex。（在Java平台类库中有一些类应该定义成不可变的但是并没有，例如java.util.Date和java.awt.Point）要慎重考虑将值较大的对象定义成不可变的，例如String和BigInteger。只有在已经确认必须获得令人满意的性能后，才应该为不可变类提供共有的可变的伴生类（Item 67）。<br>  有一些类的（实现）不变性是不现实的。如果一个类不能被定义成不可变的，就要尽可能的限制其可变性。减少对象可能存在的状态数使得更容易推理分析对象，并减少出错的可能性。因此，除非有强有力的理由，否则将每一个字段定义成终态的。结合该条款和条款15的建议，你的自然倾向应该是声明每一个字段为public final，除非有充分的理由不这么做。<br>  构造函数应该创建完全初始化的对象，并建立所有不变量。除非有说服力的理由，否则不要在构造函数或静态工厂以外提供公共的初始化方法。同样的，不要提供一个“重新初始化”的方法，来使对象能够被重用，就好像它是用不同的初始状态构造的一样。这些方法通常都是以增加复杂性为代价，然后提供仅有的一点性能优势。<br>  CountDownLatch类例证了该规则。它是可变的，但是其状态空间有意保持较小。你创建一个实例，使用它一次后，就销毁了：一旦倒计时锁存器（countdown latch）的计数达到零，你就不能再使用它了。<br>  关于该条款中的Complex类，最后还要提一个注意点。这个例子只是用来阐述不变性。它不是一个工业强度的复数实现。它对于复杂的乘法和除法使用了标准公式，这些公式没有正确舍入，并且为复杂的NaN和无穷数提供了很差的语义【Kahan91, Smith62, Thomas94】。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单来说，不可变类是一种实例不能被修改的类。其每个实例包含的信息在对象的整个生命中期中是固定的，因此在这个过程中观察不到任何改变。Java平台类库包含很多不可变类，包括String、包装原生类、BigInteger和BigDecimal。这么做有许多好处：不可变类比可变类更</summary>
      
    
    
    
    <category term="Java基础" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Effective Java 3rd" scheme="http://example.com/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-16 在公共类中，使用访问器方法，而不是公共字段</title>
    <link href="http://example.com/2019/02/24/%E5%9C%A8%E5%85%AC%E5%85%B1%E7%B1%BB%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E5%99%A8%E6%96%B9%E6%B3%95%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5/"/>
    <id>http://example.com/2019/02/24/%E5%9C%A8%E5%85%AC%E5%85%B1%E7%B1%BB%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E5%99%A8%E6%96%B9%E6%B3%95%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5/</id>
    <published>2019-02-24T10:14:03.000Z</published>
    <updated>2023-02-07T03:06:46.956Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，你可能想要编写组合了实例字段的类没有其他任何目的：</p><pre><code>//Degenerate classes like this should not be public !class Point &#123;    public double x;    public double y;&#125;  </code></pre><p>  因为这些类的数据字段可以直接被访问，这些类具有封装的优势（Item 15）。你无法在不改变API的情况下改变其表示形式，也无法强制执行不变量，并且当字段被访问时，无法采取辅助措施。坚持面向对象程序员对着种类深恶痛绝，认为应该被包含私有字段和公共访问方法（getter）的类替代，对于可变类来说，应该包含存取器（setter）（设置方法）：</p><pre><code>//Encapsulation of data by accessor methods and mutatorsclass Point &#123;    private double x;    private double y;    public Point(double x, double y) &#123;        this.x = x;        this.y = y;     &#125;public double getX() &#123; return x; &#125;public double getY() &#123; return y; &#125;public void setX(double x) &#123; this.x = x; &#125;public void setY(double y) &#123; this.y = y; &#125;&#125;  </code></pre><p>  当然,在面对公共类时，坚持面向对象的程序员是正确的：如果一个类在其包以外可以被访问，则需要提供访问器方法，来维持改变类的内部展示的灵活性。如果公共类暴露其数据字段，则所有改变其内不展示的希望都会消失，因为客户端代码遍布各处了。<br>  然而，如果一个类是包私有的或者是私有内部类，那么暴露其数据字段不会有本质问题-假设他们在描述该类提供的抽象方面做了足够的工作。无论是类的定义还是使用它的客户端代码中，这种方式比提供访问方法方式产生更少的视觉混乱。虽然客户端代码被绑定到类的内部展示上，但是这些代码被限定在包含该类的包中。如果需要修改类的内不展示，那么你可以在不触及包外任何代码的情况下进行更改。在私有内部类的案例中，变更范围被进一步限制在外围类（附寄类）里。<br>  Java平台类库中的个别几个类违反了公共类不应该直接暴露字段的建议的类。突出的示例包括java.awt包中的Point和Dimention类。这些类不仅不值得模仿，而且应该被当做反面教材。正如条款67所述，暴露Dimension类内部（数据）的决定导致严重的性能问题，且该问题至今还存在。<br>  尽管对于公共类直接暴露字段一直不是一个好的主意，但如果这些字段是不可变的，那么危害也不大。你依旧无法在不改变其API的情况下改变这个类的展示，并且在读取字段时无法对其采取辅助措施，但可以强制执行不变量。例如：这个类保证其每个实例表示一个有效时间：</p><pre><code>// Public class with exposed immutable fields - questionablepublic final class Time &#123;private static final int HOURS_PER_DAY    = 24;private static final int MINUTES_PER_HOUR = 60;public final int hour;public final int minute;public Time(int hour, int minute) &#123;    if (hour &lt; 0 || hour &gt;= HOURS_PER_DAY)        throw new IllegalArgumentException(&quot;Hour: &quot; + hour);    if (minute &lt; 0 || minute &gt;= MINUTES_PER_HOUR)    throw new IllegalArgumentException(&quot;Min: &quot; + minute); this.hour = hour;    this.minute = minute;    &#125;    ... // Remainder omitted&#125;</code></pre><p>  总之，公共类永远不要暴露可变字段。虽然公共类暴露不可变字段的情况危害小，但仍是有问题的。但是，有时候需要用包私有类或者私有内部类暴露字段，无论它是可变还是不可变的字段。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有时候，你可能想要编写组合了实例字段的类没有其他任何目的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//Degenerate classes like this should not be public !
class Point &amp;#123;
    public double x</summary>
      
    
    
    
    <category term="Java基础" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Effective Java 3rd" scheme="http://example.com/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-15 最大限度地减少类和成员的可访问性</title>
    <link href="http://example.com/2019/02/23/%E6%9C%80%E5%A4%A7%E9%99%90%E5%BA%A6%E5%9C%B0%E5%87%8F%E5%B0%91%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7/"/>
    <id>http://example.com/2019/02/23/%E6%9C%80%E5%A4%A7%E9%99%90%E5%BA%A6%E5%9C%B0%E5%87%8F%E5%B0%91%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7/</id>
    <published>2019-02-23T10:10:46.000Z</published>
    <updated>2023-02-07T03:08:54.319Z</updated>
    
    <content type="html"><![CDATA[<p>区分设计良好和设计糟糕组件的唯一重要因素是组件隐藏其内部数据的程度以及其他组件的其他实现详情。设计良好的组件会隐藏所有其实现细节，从其实现中清晰划分API。组件之间只通过API交互，并且明显在各组件内部起作用。这个称作信息隐藏或者封装的概念是软件设计中的一个重要信条【Parnas72】。</p><p>  出于多种原因，信息隐藏（封装）很重要，其中大多数基于它解耦组成系统的各个组件这一事实，允许他们被独立的开发、测试、优化、使用、理解和修改。这可以加快系统开发，因为组件可以并行开发。它减轻了维护的负担，因为组件可以被更快的理解并进行调试和替换，而不必担心损害其他组件。尽管信息隐藏本身不会导致良好的性能，但它可以实现有效的性能调整：一旦系统完成并分析确认哪些组件引起性能问题（Item 67），这些组件可以在不影响其他组件正确性的情况下被优化。信息隐藏会增强软件复用，因为非紧密耦合的组件在其他上下文中经常被证明是有用的，除了为它们开发的那些。最后，信息隐藏降低了构建大型系统的风险，因为即使系统没有，单个组件也可能成功。<br>  Java有许多工具来协助信息隐藏。访问控制机制指定【JSL,6.6】指定类、接口和成员的可访问性。一个实体的可访问性取决于其声明的位置和访问修饰符（private、protected、public）在生声明中的位置（如果有的话）。正确使用这些修饰符对信息隐藏至关重要。<br>  经验法则很简单：尽可能地使每一个类和成员不可访问。换句话说，使用符合你正在编写的软件正常运行条件的最低可能的访问级别。<br>  对于顶层的类和接口（费嵌套），只有两种可访问级别：包私有的和公共的（package-private and public）。如果使用public修饰符声明顶级的类或接口，那么这个它将是公共的；否则，它将是包私有的。如果一个类或接口可以被定义成包私有的，那就应该这么做。把它定义成包私有的，就可以将其视作实现的一部分而不是导出的接口，并且在随后发布的版本中，可以修改它、替换它或者消除它，而不必担心损害现有客户端。如果把它定义成公共的，你有责任永久支持它以保持兼容性。<br>  如果包私有的顶级类或者接口只被一个类使用，那么考虑将这个顶级类定义成一个在唯一使用它的类中的私有静态内部类（Item 24）。这会从包中的所有类到使用它的一个类降低对它的可访问性。但是，降低对不必要的公共类的可访问性远比包私有的顶级类的可访问性重要的多：公共类是包的API中的一部分，而包私有顶级类已经是其实现的一部分。<br>  对于成员（字段、方法、内部类、内部接口）来说，有四种可访问级别，按照可访问性递增的顺序列在这：</p><ul><li>private ——该成员只能被声明它的顶级类访问。</li><li>package-private——该成员可以被与声明它的类在相同包下的所有类访问。通常称其为默认权限，如果没有指定访问修饰符，这将是你获得的访问级别（接口成员除外，默认情况下是公共的）。</li><li>protected——该成员可以被声明它的类的子类（受到一些限制【JLS，6.6.2】）和与声明它的类在相同包下的所有类访问。</li><li>public——该成员可以在任何地方访问。</li></ul><p>  在认真设计完类的公共API以后，你的反应应该是将其他成员定义成私有的。只有在相同包中的另一个类确实需要访问某个成员时，才应该删除private修饰符，时该成员成为包私有的。如果你发现自己经常这么做，你应该重新审视下你的系统设计来明确是否另一个分解可能产生更好地彼此解耦的类。也就是说，私有成员和包私有成员是类的实现的一部分，并且通常不会影响其导出的API。然而，如果类实现了Serializable接口，这些字段可能会“泄漏”到导出的API中（Item 86和87）。<br>  对于公共类的成员，当访问级别从package-private变为protected时，其访问性会发生一个巨大增长。受保护成员是类的导出API的一部分，并且必须永远支持。此外，导出类的受保护成员表示对实现细节的公开承诺（Item 19）。对受保护成员的需求相对较少。<br>  有一个关键规则限制了你减少方法可访问性的能力。如果一个方法重写了父类的方法，它不能在子类中具有比在父类中更严格的访问方法【JLS,8.4.8.3】。这对于确保子类实例在父类实例是有用的任何地方有用是必要的。如果你违反了这个规则，在你试图编译这个子类的时候，编译器会生成一个错误信息。该规则的一个特殊案例是，如果一个类实现了某个接口，那么所有在接口中的类方法必须在类中声明成public的。<br>  为了便于测试你的代码，你也许会试图使类、接口或者成员比其他方式更易于访问。这一点很好。为了检测，将公共类中的私有成员定义成包私有的，这是可接受的，但是提高可访问性是不被接受的。换句话说，将一个类、接口或者成员定义成包的导出API的一部分来便于测试是不被接受的。幸运的是，这两者都不是必须的，因为测试可以作为被测试包的一部分运行，从而获得对其包私有元素的访问（权限）。<br>  公共类的实例字段应该很少公开（Item 16）。如果实例字段是非终态的或者可变对象的引用，那么将其定义为public的，就放弃了限制在字段中存储值的能力。这意味着放弃了强制执行涉及该字段不变量的能力。此外，你还放弃了在修改字段时执行任何操作的能力，因此拥有公共可变字段的类通常不是线程安全的。即使一个字段是中台的并且引用了一个不可变对象，通过将其定义成公共的，就放弃了在字段不存在时切换到新内部数据表示的灵活性。<br>  相同的建议适应于静态字段，但有一个除外。你可以通过公共静态final的字段来暴露常量，假设常量形成了类提供的抽象的组成部分。按照惯例，这些字段的名字由大写字母组成，单词由下划线划分（Item 68）。这些字段（是否）包含原生值或者包含对不可变对象的引用是至关重要的（Item 17）。一个包含可变对象引用的字段具备非终态字段的所有缺点。既然引用不能不修改，但引用对象可以被修改，这就会导致严重的后果。<br>  注意，一个非零长度的数组经常是可变的，因此类如果包含一个共有静态且终态的数组字段或者返回这样一个字段的访问器，都是错误的。如果类包含这样一个字段或者访问器，客户端就可以修改数组的内容。这是安全漏洞的常见来源：</p><pre><code>//Potential security hold!public static final Thing[] VALUES = &#123;...&#125;;</code></pre><p>请注意，某些IDE生成的访问器会会返回对私有数组字段的引用，从而导致此问题。有两种方式来解决该问题。你可以加个公共数组定义成私有的并添加一个公共的不可变集合：</p><pre><code>private static final Thing[] PRIVATE_VALUES = &#123;...&#125;;public static final List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</code></pre><p>  另一种可替换方式是：将数组定义成私有的并且添加一个返回私有数组拷贝的公共方法：</p><pre><code>private static final Thing[] PRIVATE_VALUES = &#123;...&#125;;public static final Thing[] values() &#123;    return PRIVATE_VALUES.clone();&#125;</code></pre><p>在这些备选方案之间选择时，请考虑客户端可能会对结果做什么处理。哪一种返回类型会更方便？哪一种性能更好？<br>  从Java 9开始，引入了两个额外的隐式访问级别作为模块系统的一部分。模块是一组包，就像包是一组类一样。模块可以通过其模块声明中的导出声明显式地导出一些包（按照惯例，模块声明包含在名为moudle-info.java的源文件中）。模块中未导出包的公共和受保护的成员在模块外部是不可访问的；在模块内部，可访问性不受导出声明的影响。使用模块系统允许你在模块内部包中共享类，而不需要让类对全世界可见。未导出包中公共类的公共成员和受保护成员生成两个隐式访问级别，这是正常公共级别和受保护级别的模块内类似物。这种共享的需求相对较少，通常可以通过重新安排包中的类来消除。<br>  与四个主要访问级别不同，这两个基于模块的级别主要是建议性的。如果将模块的JAV文件放在应用程序的类路上而非模块路径上，模块中的包将恢复为非模块化行为：包中公共类的所有公共成员和受保护成员具备正常的可访问性，无论包是否由模块导出【Reinhold，1.2】。对新引入的访问级别严格执行的地方是JDK本身：Java库中的非导出包确实不能再在模块以外访问。<br>  对于典型的Java程序员而言，有限的实用程序模块不仅提供访问保护，而且主要是咨询性的；为了利用它，你必须将软件包分组到模块中，在模块声明中明确其所有依赖项，重新排列源代码树，并采取特殊措施来适应来自模块内任何费模块化软件包的访问【Reinhold, 3】。现在说模块是否会在JDK自身以外被广泛应用还为时尚早。与此同时，除非你有迫切需要，否则最好避免使用它们。<br>  总之，你应该尽可能的地减少程序元素的可访问性（在合理范围内）。在认真设计了最小的公共API以后，你应该阻止任何散杂的类、接口或者成员成为API的一部分。除了作为常量的公共静态终态字段以外，公共类不应该有公共字段。确保public static final 的字段引用的对象是不可变的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;区分设计良好和设计糟糕组件的唯一重要因素是组件隐藏其内部数据的程度以及其他组件的其他实现详情。设计良好的组件会隐藏所有其实现细节，从其实现中清晰划分API。组件之间只通过API交互，并且明显在各组件内部起作用。这个称作信息隐藏或者封装的概念是软件设计中的一个重要信条【Par</summary>
      
    
    
    
    <category term="Java基础" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Effective Java 3rd" scheme="http://example.com/tags/Effective-Java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Item-14 考虑实现Comparable接口</title>
    <link href="http://example.com/2019/02/22/%E8%80%83%E8%99%91%E5%AE%9E%E7%8E%B0Comparable%E6%8E%A5%E5%8F%A3/"/>
    <id>http://example.com/2019/02/22/%E8%80%83%E8%99%91%E5%AE%9E%E7%8E%B0Comparable%E6%8E%A5%E5%8F%A3/</id>
    <published>2019-02-22T10:07:56.000Z</published>
    <updated>2023-02-07T03:07:37.416Z</updated>
    
    <content type="html"><![CDATA[<p>不像在本章节中讨论的其他方法，compareTo方法未在Object中声明，而是Comparable接口中的唯一方法。它的特征与Object的equals方法类似，除了允许简单的相等性比较还允许顺序比较，且它是通用的。为了实现Comparable接口，类应该声明其实例有一个自然顺序。为实现了Comparable接口的对象数组排序就像下面这样简单：</p><pre><code>Arrays.sort(a);</code></pre><p>  它同样易于搜索，计算极值，并且维护自动排序的Compara对象集合。例如，下面的程序，依赖于String类实现了Comparable接口的事实，会打印按字母顺序排列的集合，该集合包含去重的命令行参数：</p><pre><code>public class WordList &#123;    public static void main (String[] args)&#123;        Set&lt;String&gt; s = new TreeSet&lt;&gt;();        Collections.addAll(s, args);        System.out.println(s);    &#125;&#125;</code></pre><p>  为实现Comparable接口，你必须使你的类与所有通用算法和基于该接口的稽核实现进行交互。只需少量努力就可获得巨大的能力（力量power）。事实上，所有在Java平台库中的值类，像枚举类型（Item 34），都实现了Comparable接口。如果你正在编写一个具有明显自然顺序的值类，如字母顺序，数字顺序，年份顺序，就应该实现Comparable接口：</p><pre><code>public interface Comparable&lt;T&gt; &#123;    int compareTo(T, t);&#125;</code></pre><p>compareTo方法的通用规范与equals方法一样：<br>将此对象与指定对象进行比较以获得顺序。返回一个负整数，零，正整数，当此对象比指定对象小，相等，或者大的时候。如果指定对象的类型阻止其与该对象进行比较，则抛出ClassCastException。在以下的描述中，符号sgn(expression)指明数学符号函数，根据表达式的值是否是正数，零，或者负数，被定义成返回-1，0，1。</p><ul><li>实现者必须确保对于所有的x和y,sgn(x.compareTo(y)) &#x3D;&#x3D; -sgn(y.compareTo(x))。这意味着当且仅当y.conpareTo(x)抛出异常的时候x.compateTo(y)必须抛出异常。</li><li>实现者也必须确保关系是可传递的：(x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0)意味着x.compareTo(z) &gt; 0。</li><li>最后，实现者必须确保对于所有的z,x.compareTo(y)&#x3D;&#x3D;0意味着sgn(x.compareTo(z)) &#x3D;&#x3D; sgn(y.compareTo(z))。</li><li>特别强调，但不是必须的，(x.compareTo(y) &#x3D;&#x3D; 0) &#x3D;&#x3D; (x.equals(y))。通常来讲，任何实现了Comparable接口且校验该条件的类应该清晰的声明该事实。推荐语言是“注意：此类具有与equals方法不一致的自然顺序”。</li></ul><p>  不要被该规范的数学本质所拖延。像equals规范一样(Item 10),该规范看起来也不复杂。不像equals方法，在所有对象上强加全局等价关系，compareTo方法不必跨越不同类型的对象工作：当遇到不同类型的对象时，允许compareTo方法抛出ClassCastException异常。通常，它确实是这么做的。规范确实允许交互式比较，这些比较通常在被比较对象实现的接口中定义。<br>  就像校验hashCode规范的类会破坏其他依赖散列的类一样，校验compareTo规范的类会破坏依赖于比较的类。依赖于比较的类包括有序集合TreeSet和TreeMap以及包含搜索和排序算法的实用程序类集合和数组。<br>  让我们复习下compareTo规范的规定。第一条规定说如果你颠倒两个对象引用之间的比较方向，那么预期的事情就会发生：如果第一个对象小于第二个，那么第二个对象必须比第一个大；如果第一个对象等于第二个，那么第二个对象必须等于第一个；且如果第一个对象大于第二个，那么第二个对象必须小于第一个。第二条规定说如果一个对象大于第二个，第二个对象大于第三个，那么第一个对象必须大于第三个。最后一条规定说，所有相等的对象相互比较时必须生成同样的结果。<br>  这三个条款的一个结果是compareTo方法强加的相等测试必须遵守equals规范强加的限制：自反性、对称性和传递性。因此，同样的警告适应如下：除非你愿意放弃面向对象抽象的好处，否则不可能在遵守（保留）compareTog规范的同时使用一个新的值组件扩展可实例化类（Item 10）。同样的解决方法也适用。如果你想给实现了Comparable接口的类添加值组件，那就不要扩展它；而是要写一个包含第一个类实例的不相关的类。然后提供一个“试图”方法返回包含的实例。这可以让你在包含的类上自由地实现任何你喜欢的compareTo方法，同事允许其客户端在需要时查看包含类的实例作为包含类的实例。<br>  compateTo规范的最后一段是强烈建议而非必须的，简单地说，compareTo方法强加的相等性测试通常应该返回与equals方法相同的结果。如果遵循了该条款，则compareTo方法强加的顺序与equaks一致。如果违反了，则说明顺序与equals不一致。compareTo方法强执行与equals不一致的顺序的类仍然有效，但包含该类元素的有序集合可能不遵守相应集合接口（Collection，Set和Map）的通用规范。这是因为这些接口的通用规范定义在equals方法中，但是有序集合使用compareTo方法加强的相等测试来代替equals。如果发生这种情况，这不是灾难，但要注意。<br>  例如，考虑下BigDecimal类，其compareTo方法与equals不一致。如果你创建一个空的HashSet实例并添加new BigDecimal(“1.0”)和new BigDecimal(“1.00”)，该集合将包含两个元素，因为这两个添加到集合中的BigDecimal实例在使用equals方法比较时是不相等的。然而，如果你使用TreeSet代替HashSet执行相同的程序，该集合中将只包含一个元素，因为这两个BigDecimal实例在使用compareTo方法比较时是相等的。（查看BigDecimal文档了解详情）<br>  编写一个compareTo方法与编写一个equals方法一样，但有几个关键的不同之处。因为Comparable接口是参数化的，compareTo方法是静态类型的，因此你不需要类型检查或者转换其参数。如果参数为空，调用将抛出空指针异常，并且只要方法尝试访问其成员，就会抛出空指针异常。<br>  在compareTo方法内，变量比较的是顺序而不是相等性。为比较对象引用变量，请递归调用compareTo方法。如果变量没有实现Comparable接口或者你需要一个非标准的排序，使用Comparator代替。你可以为条款10中的CaseInsensitiveString的compareTo方法编写自己的比较器或者使用已存在的：</p><pre><code>// Single-field Comparable with object reference fieldpublic final class CaseInsensitiveString implements Comparable&lt;CaseInsensitiveString&gt; &#123;    public int compareTo(CaseInsensitiveString cis) &#123;        return String.CASE_INSENSITIVE_ORDER.compare(s, cis.s);    &#125;... // Remainder omitted&#125;</code></pre><p>  注意，CaseInsensitiveString实现了Comparable<CaseInsensitiveString>接口。这意味着CaseInsensitiveString实例只能与另一个CaseInsensitiveString实例进行比较。这是声明一个类实现Comparable接口时遵循的正常模式。<br>  本书的早先版本建议compareTo方法使用关系运算符整数原生字段，使用静态方法Double.compare和Float.compare比较浮点原生字段。在Java 7中，静态的compare方法被添加到了所有的Java包装原生类中。在compareTo方法中使用关系运算符是冗余且容易出错的，不再推荐使用。<br>  如果一个类有多种重要字段，那么比较他们的顺序是至关重要的。从最重要的字段开始并逐步完成。如果比较结果是零意外的任何结果（零表示相等），那么你就完成了，只返回结果。如果最重要的字段是相等的，再比较次重要的字段，并依次比较下去，直到你发现一个不相等的字段或者比较到最不重要的字段。这里是条款11中PhoneNumber类的compareTo方法使用该技术的开始实例：</p><pre><code>// Multiple-field Comparable with primitive fieldspublic int compareTo(PhoneNumber pn) &#123;    int result = Short.compare(areaCode, pn.areaCode);    if (result == 0)  &#123;        result = Short.compare(prefix, pn.prefix);        if (result == 0)            result = Short.compare(lineNum, pn.lineNum);    &#125;    return result;&#125;</code></pre><p>  在Java 8中Comparator接口配备了一系列比较器构造函数，可以流利地构建比较器。这些比较器可用于实现compareTo方法，这是Comparable接口所需要的。许多程序员更喜欢这种方式的简洁性，尽管它的性能成本适中：在我的机器上对PhoneNumber实例数组排序大约慢10%。在使用该方式时，请考虑使用Java的静态导入功能，以便可以通过简单的名称引用静态比较器构造方法，以简化和简洁（程序）。下面是PhoneNumber类的compareTo方法使用该方式的实现：</p><pre><code>// Comparable with comparator construction methodsprivate static final Comparator&lt;PhoneNumber&gt; COMPARATOR =    comparingInt((PhoneNumber pn) -&gt; pn.areaCode)        .thenComparingInt(pn -&gt; pn.prefix)        .thenComparingInt(pn -&gt; pn.lineNum);public int compareTo(PhoneNumber pn) &#123;return COMPARATOR.compare(this, pn);&#125;  </code></pre><p>  该实现使用两个比较器构造方法在类初始化的时候构建了一个比较器。第一个是comparingInt。它是一个比较器，接收一个键提取函数（key extractor function），将对象引用映射到int类型的键，并返回一个根据该键对实例排序的比较器。在之前的示例中，comparingInt接收一个lambda(),从PhoneNumber中提取地区码，并且返回根据地区码对电话号码进行排序的比较器Comparator。注意，lambda显示指定输入参数的类型（PhoneNumber pn）。事实证明，在这种情况下，Java的类型推断不足以为自己计算类型，所以我们被迫帮助它来使程序通过编译。<br>  如果两个电话号码有相同的地区码，我们就需要进一步细化比较，这正是第二个比较器构造方法thenComparingInt做的。它是Comparator上的一个实例方法，接收一个int类型的键提取函数，并返回一个比较器，该比较器首先应用原是比较器，然后使用提取键来断开关系。你可以根据需要尽可能多的对thenComparingInt叠加调用，从而产生字典顺序。在上面的示例中，我们叠加了两个队thenComparingInt的调用，结果是按照第二个字段是前缀（prefix），且第三个字段是线性码（line number）的顺序调用。注意，我们不必指定传递给thenComparingInt的任一调用的键提取函数的参数类型：Java的类型推断足够聪明，可以为自己解决该问题。<br>  Comparator类具有完整的构造方法。对原生类型long和double有类似comparingInt和thenComparingInt的比较器。int版本也可以用于范围更小的整数类型，如short，以及我们的PhoneNumber示例。double版本也可以用于float。其提供的比较器覆盖Java的所有数字原生类型。<br>  对于对象引用类型也有比较器构造函数。名为comparing的静态方法，有两个重写实现。一个接收关键字提取并使用关键字的自然顺序。第二个接收关键字提取和用于提取的关键字的比较器。实例方法还有第三种重写实现，名为thenComparing。其中一个重载只接收一个比较器，并使用该比较器提供第二种顺序。第二个重载只接收一个关键字提取器并且使用关键字的自然顺序作为第二种顺序。最后一种重载接收一个关键字提取器和使用提取的关键字的比较器。<br>  偶尔的，你可以看下compareTo方法和基于以下事实的方法：如果第一个值小于第二个值，则两个值之间的差值为负，如果两个值相等，则差值为零，如果第一个值较大则为正直。这里是实例：</p><pre><code>// BROKEN difference-based comparator - violates transitivity!static Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() &#123;    public int compare(Object o1, Object o2) &#123;    return o1.hashCode() - o2.hashCode();    &#125;&#125;;</code></pre><p>不要使用该技巧。它充满了整数溢出和IEEE 754浮点运算伪像的危险【JLS 15.20.1, 15.21.1】。此为，所得到的方法不可能比使用本条款中描述的技术编写的方法更快。或者使用静态比较方法：</p><pre><code>// Comparator based on static compare methodstatic Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() &#123;    public int compare(Object o1, Object o2) &#123;        return Integer.compare(o1.hashCode(), o2.hashCode());    &#125;&#125;;</code></pre><p>或者使用比较器构造方法：</p><pre><code>// Comparator based on Comparator construction methodstatic Comparator&lt;Object&gt; hashCodeOrder =    Comparator.comparingInt(o -&gt; o.hashCode());</code></pre><p>  总之，无论何时实现具有合理排序的值类，都应该使实现Comparable接口，以至于使其实例可以容易的排序、查询和在基于相等的集合中使用。当比较在compareTo方法中实现的字段值时，应该避免使用运算符。作为替换，在包装原生类中使用静态比较方法或者在Comparator接口中使用比较器构造方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不像在本章节中讨论的其他方法，compareTo方法未在Object中声明，而是Comparable接口中的唯一方法。它的特征与Object的equals方法类似，除了允许简单的相等性比较还允许顺序比较，且它是通用的。为了实现Comparable接口，类应该声明其实例有一个</summary>
      
    
    
    
    <category term="Java基础" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Effective Java 3rd" scheme="http://example.com/tags/Effective-Java-3rd/"/>
    
  </entry>
  
</feed>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Doggie">
    
    <title>
        
            Item-10 重写equals方法时请遵循通用规范 |
        
        Keep Moving
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/brands.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/logo.svg","favicon":"/images/logo.svg","avatar":"/images/avatar.svg","font_size":null,"font_family":"STSong, STHeiti","hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/images/bg.svg","description":"请在这里输入你想对全世界每个人要说的话...","font_color":null,"hitokoto":true},"scroll":{"progress_bar":false,"percent":true}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":false},"comment":{"enable":false,"use":"valine","valine":{"appid":"uV1DqTVgOHpeh50rftSyg4NR-gzGzoHsz","appkey":"0FhpBTmkC3B0LaUFCRJrlk0H","server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":false},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original article title","author":"Original article author","link":"Original article link"}
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="logo-title" href="/">
               Keep Moving
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">Item-10 重写equals方法时请遵循通用规范</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Doggie</span>
                            
                                <span class="author-label">Lv4</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2019-02-18 17:44:35</span>
        <span class="mobile">2019-02-18 17:44</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-02-07 11:06:32</span>
    </span>
    
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Effective-Java-3rd/">Effective Java 3rd</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>6k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>22 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <p>重写<code>equals</code>方法很简单，但是很多地方会出错，且后果严重。避免问题的最简单的方式是不重写<code>equals</code>方法，使类的每一个实例只跟它自身相等。如果符合以下任何条件，都是正确的做法：</p>
<p>每个类的实例本质上都是唯一的。这对表示活动实体而非值的类（例如Thread类）来说是正确的。<code>Object</code>类提供的<code>equals</code>实现对这些类来说具有非常正确的行为。<br>类不需要提供“逻辑相等”测试。例如，<code>java.util.regax.Pattern</code>可以重写<code>equals</code>方法来检查两个<code>Pattern</code>实例是否表示相同的正则表达式，但是设计者不认为客户端需要或者想要这个功能。在这种情况下，从<code>Object</code>类中继承<code>equals</code>实现是理想的选择。<br>父类已经重写了<code>equals</code>方法，则父类的行为适合这些子类。例如，大部分<code>Set</code>实现从<code>AbstractSet</code>继承<code>equals</code>方法实现，List实现从<code>AbstractList</code>继承，<code>Map</code>从<code>AbstractMap</code>继承。<br>类是私有的或包级私有的，可以确定它的<code>equals</code>方法永远不会被调用。如果你非常厌恶风险，可以重写<code>equals</code>方法来确保它不会被意外地调用：</p>
<pre><code>@Override public boolean equals(Object o) &#123;
    throw new AssertionError(); //Method is never called
&#125;
</code></pre>
<p>  那么什么时候适合重写<code>equals</code>方法呢？当一个类有逻辑相等(logical equality)的概念，逻辑相等不仅不同于对象标识(object identity)，而且其父类没有重写<code>equals</code>方法。这通常是值类的情况。所谓值类就是代表某个值的类，比如<code>Integer</code>或者<code>String</code>。程序员使用<code>equals</code>方法比较值对象的引用，期望确认他们是否逻辑相等，而不是引用相同的对象。重写<code>equals</code>方法不仅对满足程序员的期望是必须的，它还可以使实例作为Map的键(key)或者Set里的元素，同时具有可预测的、理想的行为。<br>  某种值类不需要重写<code>equals</code>方法，它使用实例控制(Item 1)来确保每个值至多存在一个对象。枚举类型就属于这种类（Item 34）。对这些类来说，逻辑相等等同于对象标识，因此，<code>Object</code>类的<code>equals</code>方法功能上与逻辑equals&#96;&#96;方法一样。<br>  当你重写<code>equals</code>方法时，必须遵循它的通用规范。下面是来自<code>Object</code>类的规范：<br> <code>equals</code>方法实现了一个等价关系。它有以下特性：</p>
<ul>
<li>自反性：任何非空引用值x，<code>x.equals(x)</code>必须返回true。</li>
<li>对称性：任何非空引用值x和y,当且仅当<code>y.equals(x)</code>返回true时，<code>x.equals(y)</code>必须返回true。</li>
<li>传递性：任何非空引用值x,y,z，<code>x.equals(y)</code>返回true，且<code>y.equals(z)</code>返回true,那么<code>x.equals(z)</code>必须返回true.</li>
<li>一致性：任何非空引用值x和y，如果在<code>equals</code>比较中的信息没有修改，那么多次调用<code>x.equals(y)</code>必须始终返回true或者始终返回false。</li>
</ul>
<p>任何非空引用值x，<code>x.equals(null)</code>必须返回false。<br>  除非你擅长数学，否则这看起来有点可怕，但不要忽视它！如果违反它，你将会发现你的程序行为异常或者崩溃，并且很难找到失败的根源。套用John Donne的话法，没有哪个类是孤立存在的。一个类的实例被频繁地传递给另一个类的实例。包括所有集合类在内的许多类，都依赖于传递给他们且遵循<code>equals</code>规范对象。<br>  既然已经意识到违反<code>equals</code>规范的危险性，让我们详细介绍下这个规范。好消息是它们表面看起来难以理解，但真的不是很复杂。一旦你理解了，将不难遵循它。<br>  那么等价关系是什么呢？简单地讲，它将一系列元素划分成子集的运算符，这些子集中的元素彼此相等。这些子集被称作是等价类。为使<code>equals</code>方法有用，每个等价类中的所有元素必须可以从用户的角度进行互换。现在让我们依次审阅下这五个要求：<br>  自反性(Reflexivity)-第一个要求仅表示对象必须与自身相等。很难想象无意中违反这一规范。如果你已经违反这一条并将你的某个类的实例添加到集合中，那么<code>contains</code>方法将会告诉你集合不包含你刚刚添加的实例。<br>  对称性(Symmetry)-第二个要求是任何两个对象必须就它们是否相等达成一致。不像第一个要求，不难想象无意中违反这一要求。例如，思考下面这个类，它实现了不区分大小写的字符串。字符串由<code>toString</code>保留，但在<code>equals</code>比较中被忽略:</p>
<pre><code>//Broken - violates symmetry !
public final class CaseInsensitiveString &#123;
    private final String s;

    public CaseInsensitiveString(String s)&#123;
        this.s = Objects.requireNonNull(s);
    &#125;

    //Broken - violates symmetry!
    @Override
    public boolean equals(Object o)&#123;
        if(o instanceof CaseInsensitiveString)
            return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);
        if(o instanceof String) //One-way interoperability!
            return s.equalsIgnoreCase((String) o);
        return false;
    &#125;
    ... // Remainder omitted
&#125;
</code></pre>
<p>  本类中<code>equals</code>方法试图与普通字符串进行交互。假设我们有一个不区分大小写的字符串和一个普通字符串：</p>
<pre><code>CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;);
String s = &quot;polish&quot;;  
</code></pre>
<p>  按照预期，<code>cis.equals(s)</code>返回true。但问题是，尽管<code>CaseInsensitiveString</code>中的<code>equals</code>方法知道是普通字符串，但<code>String</code>中的<code>equals</code>方法却忽略了不区分大小写的字符串。因此，<code>s.equals(cis)</code>返回false，明显违反了对称性。假设将一个不区分大小写的字符串放入集合中：</p>
<pre><code>List&lt;CaseInsensitiveString&gt; list = new ArrayList&lt;&gt;();
list.add(cis);  
</code></pre>
<p>  <code>list.contains(s)</code>会返回什么呢？谁知道？在当下的OpenJDK实现中，它恰好会返回false，但这只是一种实现方式。在其他实现中，它可以很容易的返回true或者抛出运行异常。一旦违反了<code>equals</code>规范，你将不知道其他对象在面对你的对象时会如何表现了。<br>  要消除这个问题，只需从<code>equals</code>方法中删除试图与<code>String</code>交互的恶意尝试。一旦你这么做了，你可以将方法重构成一条返回语句：</p>
<pre><code>@Override public boolean equals(Object o)&#123;
    return o instanceof CaseInsensitiveString &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);
&#125;  
</code></pre>
<p>  传递性(Transitivity)-<code>equals</code>规范的第三个要求是，如果一个对象与第二个对象相等并且第二个对象与第三个对象相等，那么第一个对象必须与第三个对象相等。同样，也不难想象无意中违反这一要求的后果。考虑下子类添加一个值组件到父类的情况。换句话说，子类添加了一条影响<code>equals</code>比较的信息。让我们从一个简单的、不可变的二维整数类型Point类开始：</p>
<pre><code>public class Point &#123;
    private final int x;
    private final int y;

    public Point(int x, int y)&#123;
        this.x = x;
        this.y = y;
    &#125;

    @Override 
    public boolean equals(Object o)&#123;
        if(! (o instanceof Point))
            return flase;
        Point p = (Point) o;
        return p.x == x &amp;&amp; p.y == y;
    &#125;

    ... // Remainder omitted
&#125;  
</code></pre>
<p>假设你想继承这个类，将表示颜色的<code>Color</code>类添加到<code>Point</code>类中：</p>
<pre><code>public class ColorPoint extends Point &#123;
    private final Color color;

    public ColorPoint(int x, int y, Color color) &#123;
        super(x, y);
        this.color = color;
    &#125;

    // Remainder omitted
&#125;  
</code></pre>
<p>  <code>equals</code>方法应该是什么样子？如果完全忽略它，则实现从<code>Point</code>类继承，并且在<code>equals</code>比较中，颜色信息被忽略。尽管你没有违反<code>equals</code>规范，但很明显这是不可接受的。假设你写了一个<code>equals</code>方法，它只在其参数是另一个具有相同位置和颜色的<code>ColorPoint</code>实例时返回true：</p>
<pre><code>//Broken - violates symmetry !
@Override public boolean equals(Object o) &#123;
    if(! (o instanceof ColorPoint))
        return false;
    return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;
&#125;  
</code></pre>
<p>  这个方法是有问题的，你将一个<code>Point</code>对象与<code>ColorPoint</code>对象进行比较时，也许会得到不同的结果，反之亦然。前者的比较忽略了颜色，而后者的比较总是返回false，因为参数的类型是错误的。为了使问题更加具体，我们创建一个<code>Point</code>对象和一个<code>ColorPoint</code>对象：</p>
<pre><code>Point p = new Point(1,2);
ColorPoint cp = new ColorPoint(1,2,Color.RED);  
</code></pre>
<p>  <code>p.equals(cp)</code>返回true，但是<code>cp.equals(p)</code>返回false。你也许想使用<code>ColorPoint.equals</code>通过“混合比较”的方式来解决该问题：</p>
<pre><code>//Broken - violates transitivity!
@Override public boolean equals(Object o) &#123;
    if (!(o instanceof Point))
        return false;

    //If o is a normal Point, do a color-bind comparison
    if(!(o instanceof ColorPoint))
        return o.equals(this);

    // o is a ColorPoint; do a full comparison
    return super.equals(o) &amp;&amp; ((ColorPoint) o).color == color;
&#125;
</code></pre>
<p>这种实现确实提供了对称性，但却丧失了传递性：</p>
<pre><code>ColorPoint p1 = new ColorPoint(1,2,Color.RED);
Point p2 = new Point(1,2);
ColorPoint p3 = new ColorPoint(1,2,Color.BLUE);
</code></pre>
<p>现在<code>p1.equals(p2)</code>和<code>p2.equals(p3)</code>返回true，但是<code>p1.equals(p3)</code>返回false，明显违反了传递性。前面两个比较是不考虑颜色信息的，但第三种比较时却包含了颜色信息。<br>  此外，这种方法可以导致无限递归：假设有两个<code>Point</code>的子类，<code>ColorPoint</code>和<code>SmellPoint</code>，每一个都包含上述<code>equals</code>方法。那么调用<code>myColorPoint.equals(mySmellPoint)</code>方法将会抛出<code>StackOverflowError</code>异常。<br>  那么如何解决？事实证明，这是面向对象语言中等价关系的基本问题。除非你愿意放弃面向对象抽象的好处，否则无法继承可实例化的类并在保留<code>equals</code>规范的同时添加值组件。<br>  你也许听说过，可以继承一个可实例化类并添加一个值组件，同时在<code>equals</code>方法中使用<code>getClass</code>测试代替<code>instanceof</code>测试来保留<code>equals</code>规范：</p>
<pre><code>//Broken - violates Liskov substitution principle (page 43)
@Override 
public boolean equals(Object o)&#123;
    if(o == null || o.getClass() != getClass())
        return false;
    Point p = (Point) o;
    return p.x == x &amp;&amp; p.y == y;
&#125;
</code></pre>
<p>只有对象具有相同的实现类时，他们才有等效的效果。这看起来也许不坏，但后果是不能接受的：<code>Point</code>子类的实例仍然是一个<code>Point</code>的实例，且其仍然需要作为<code>Point</code>来运行，但是如果使用上述实现，该子类将不会实现<code>Point</code>的功能！假设我们想写一个方法来判断一个<code>Point</code>对象是否在<code>unitCircle</code>集合中。这里是一种实现方式：</p>
<pre><code>//Initialize unitCircle to contain all Points on the unit circle
private static final Set&lt;Point&gt; unitCircle = Set.of(
        new Point( 1, 0), new Point(0, 1),
        new Point(-1, 0), new Point(0,-1));

public static boolean onUnitCircle(Point p)&#123;
    return unitCircle.contains(p);
&#125;
</code></pre>
<p>尽管这不是实现此功能最快的方式，但它可以正常工作。假设以不添加值组件的简单方式继承<code>Point</code>类，例如，让其构造函数跟踪已创建的实例数：</p>
<pre><code>public class CounterPoint extends Point &#123;
    private static final AtomicInteger counter = new AtomicInteger();

    public CounterPoint(int x, int y)&#123;
        super(x, y);
        counter.incrementAndGet();
    &#125;
    public static int numberCreated() &#123;
        return counter.get();
    &#125;
&#125;
</code></pre>
<p>  里氏替代原则(Liskov substitution principle)指出，任何类型的重要属性也要同样适应于其所有的子类型，以便为该类型编写的任何方法在其子类型上应该同样适用【Liskov87】。这是我们之前声明的一个正式陈述：<code>Point</code>的子类仍然是<code>Point</code>且必须作为<code>Point</code>来看待。但假设我们传递一个<code>CounterPoint</code>给<code>onUnitCircle</code>方法。如果Point类使用基于getClass的<code>equals</code>方法，无论<code>CounterPoint</code>实例的x和y坐标如何，onUnitCircle方法将返回false。这是因为大多数集合（包括<code>onUnitCircle</code>方法使用的<code>HashSet</code>）使用<code>equals</code>方法来测试是否包含元素，并且没有任何<code>CounterPoint</code>实例等于<code>Point</code>实例。但是，如果在<code>Point</code>上使用合适的基于<code>instanceof</code>的<code>equals</code>方法，那么在使用<code>CounterPoint</code>实例时，相同的<code>onUnitCircle</code>方法可以正常工作。<br>  尽管没有一种满意的方式来继承可实例化类并增加一个值组件，但有一个很好的变通方法：遵循Item 18的建议，“优先使用组合而不是继承”。取代继承<code>Point</code>类的<code>ColorPoint</code>类，在<code>ColorPoint</code>类中定义一个私有的<code>Point</code>属性和一个公共的试图(<code>view</code>)方法（Item 6），用来返回具有相同位置的<code>ColorPoint</code>对象：</p>
<pre><code>//Adds a value component without violating the equals contract
public class ColorPoint &#123;
    private final Point point;
    private final Color color;

    public ColorPoint(int x, int y, Color color)&#123;
        point = new Point(x, y);
        this.color = Objects.requireNonNull(color);
    &#125;

    /**
    *  Return the point-view of this color point.
    */
    public Point asPoint() &#123;
        return point;
    &#125;

    @Override public boolean equals(Object o)&#123;
        if(!(o instanceof ColorPoint))
            return false;
        ColorPoint cp = (ColorPoint) o;
        return cp.point.equals(point) &amp;&amp; cp.color.equals(color);
    &#125;

    ... // Remainder omitted
&#125;
</code></pre>
<p>  在Java平台中有一些类确实可以继承可实例化类且可以添加一个值组件。例如。<code>java.sql.Timestamp</code>继承了<code>java.util.Date</code>并添加了一个<code>nanoseconds</code>变量。<code>Timestamp</code>的<code>equals</code>实现确实违反了对称性，如果Timestamp和Date对象在同一个集合中使用，或者以其他方式混合使用，可能引起程序不正常行为。<code>Timestamp</code>类有一个免责声明，提醒程序员不要混用<code>Timestamp</code>和<code>Date</code>。虽然只要你将他们分开，就不会有任何问题，但没有什么可以组织你将他们混合在一起，且错误结果可能很难调试。<code>Timestamp</code>类的这个行为是一个错误，不应该被效仿。<br>  请注意，你可以添加一个值组件到抽象类的子类中而不违反equals规范。这对你通过遵循Item23中的建议（“优先考虑层级来代替标记类”）而获得的类层次结构是非常重要的。例如，你写了一个抽象类Shape，且没有值组件，一个子类Circle添加一个radius属性，另一个Rectangle子类包含length和width属性。只要不直接创建父类实例，前面展示的问题就不会出现。<br>  一致性(Consistency)-equals规范的第四个要求是如果两个对象相等，他们必须任何时刻相等除非一个（或者两个）改变了。换句话说，可变对象可以在不同的时间与不同的对象相等，而不可变对象就不能。当你编写一个类时，仔细思考下其是否应该设计成不可变的（Item 17）。如果你认为应该这么做，那么请确保你的equals方法强制执行如下限制：相等的对象永远相等，不相等的对象始终不等。<br>  一个类不管是否不可变，都不要编写依赖于不可靠资源的equals方法。如果违反这个禁令，它将很难满足一致性需求。例如，java.util.URL的equals方法依赖于与URL关联的主机的IP地址的比较。将主机名转换为IP地址可能需要网络访问，并且无法保证随着时间的推移产生相同的结果。这也许导致URL的equals方法违反equals规范，并在实践中引起问题。URL类的equals方法的行为是一个重大错误，不应该被效仿。不幸的是，由于兼容性需要，它不能被更改。为避免这个问题，equals方法应该只对内存驻留对象执行精确计算。<br>  非空性(Non-nullity)-equals规范的最后要求缺少官方名称，因此我冒昧的称其为“非空性”。他要求所有的对象跟null不相等。虽然很难想象在调用o.equals(null)时偶然返回true，但不难想象会抛出一个NullPointerException异常。通用规范禁止这么做。许多类中的equals方法都会阻止对象为null的情况：</p>
<pre><code>@Override public boolean equals(Object o) &#123;
    if(o == null)&#123;
        return false;
    &#125;
    ...
&#125;
</code></pre>
<p>这个判断不是必须的。要测试其参数是否相等，equals方法必须首先将其参数转换成合适的类型，以便调用访问器或允许访问的属性。在做转换前，equals方法必须使用instanceof运算符来检查参数是否是正确的类型：</p>
<pre><code>@Override public boolean equals(Object o) &#123;
    if(!(o instanceof MyType))
        return false;
    MyType mt = (MyType) o;
    ...
&#125; 
</code></pre>
<p>如果此类型检查漏掉，并且给equals方法传入了错误类型的参数，那么equals方法就会抛出ClassCastException，这就违反了equals规范。但是，如果第一个操作数为null，则指定instanceof运算符返回false，而不管第二个操作数是什么类型【JLS，15.20.2】。因此，如果给equals方法传入null，类型检查就返回false，所以不需要显式的null检查。<br>  总而言之，以下是编写高质量的equals方法的配方(recipe)：</p>
<p>使用运算符来检查参数是否是是对象的引用。如果是，则返回true。这只是一种性能优化，但是如果比较很昂贵的话，那就值得做。<br>使用instanceof运算符来检查参数是否正确类型。如果不正确，则返回false。通常，正确的类型是equals方法所在的那个类。有时，该类实现了一些接口。如果类实现了一个接口，该接口优化了equals规范来允许跨类实现接口的类进行比较，则使用接口。像Set,List,Map.Entry这些集合接口具有该特性。<br>将参数转换为正确类型。因为强制转换前会进行instanceof检测，所以保证成功。<br>对于类中的“重要”字段，检查参数的该属性是否与该对象相应的属性匹配。如果这些检测都成功，则返回true，否则返回false。如果步骤2中的类型是接口，则必须使用接口方法访问参数的属性；如果类型是一个类，那么你可以直接访问这些属性，这取决于属性的可访问性。<br>对那些非float或者double类型的基本类型，使用运算符进行比较；对于对象引用变量，递归调用equals方法；对于float基本类型的变量，使用静态的Float.compare(float, float)方法，对于double基本类型的变量，使用Double.compare(double, double)方法。由于存在Float.Nan,-0.0f和类似的double类型的值，所以需要对float和double属性进行特殊处理；详情请看JLS 15.21.1或者Float.equals的文档；尽管你可以使用静态的Float.equals和Double.equals方法比较float和double基本类型属性，这意味着在每次比较时会引发自动装箱，这会降低性能。对于数组属性，将这些准则应用于每个元素。如果数组属性中的每一个元素都是重要的，使用重载的Arrays.equals方法。</p>
<p>一些对象引用变量也许会合理的包含null。为避免空指针的可能性，使用静态方法Objects.equals(Object, Object)方法来检查这些变量的相等性。</p>
<p>像上面的CaseInsensitiveString类，变量比较相对于简单的相等性检测更复杂。如果是这种情况，要保存属性的一个的规范形式，以便equals方法可以在规范形式上做一个廉价而精确的比较，而不是一个开销很大的非标准比较。这项技术非常适合不可变的类（Item 17）；一旦对象发生改变，请务必使规范形式保持最新。<br>equals方法的性能也许会受变量比较顺序的影响。为了获得最佳性能，你应该首先比较最可能不相同的变量，开销比较小的变量，或者理想情况下两者都满足。你一定不要比较那些不是对象逻辑状态的变量，像lock这种用于同步操作的变量。无需比较派生字段，可以从“重要字段”计算出来，但这么做可以会提高equals方法的性能。如果派生字段相当于整个对象的摘要描述，那么比较该字段将节省在比较实际数据失败时的花销。例如，假设有一个Polygon类，并缓存该区域。如果两个多边形的面积不相等，则无需费心比较它们的边和定点。<br>  当你完成自己的equals方法时，自问三个问题：它是对称性的吗？它是传递性的吗？它是一致性的吗？除此以外；编写单元测试来检查，除非使用AutoValue框架（49页）来生成你的equals方法，在这种情况下，你可以安全的省略测试。如果持有的属性失败，请找出原因，并相应地修改equals方法。当然，你的equals方法必须满足其他两个属性（自反性和非空性），但是这两个属性通常会满足。<br>  在这个简单的PhoneNumber类中展示了根据前面的配方构造的equals方法：</p>
<pre><code>// Class with a typical equals method
public final class PhoneNumber &#123;
    private final short areaCode, prefix, lineNum;
    public PhoneNumber(int areaCode, int prefix, int lineNum) &#123;
        this.areaCode = rangeCheck(areaCode, 999, &quot;area code&quot;);
        this.prefix   = rangeCheck(prefix,   999, &quot;prefix&quot;);
        this.lineNum  = rangeCheck(lineNum, 9999, &quot;line num&quot;);
    &#125;
    private static short rangeCheck(int val, int max, String arg) &#123;     if (val &lt; 0 || val &gt; max)
            throw new IllegalArgumentException(arg + &quot;: &quot; + val);
        return (short) val;
    &#125;
    @Override public boolean equals(Object o) &#123; 
        if (o == this)
            return true;
        if (!(o instanceof PhoneNumber))
            return false;
        PhoneNumber pn = (PhoneNumber)o;
        return pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix
            &amp;&amp; pn.areaCode == areaCode;
    &#125;
... // Remainder omitted
&#125;
</code></pre>
<p>这里是最后几个警告：</p>
<p>重写equals方法时一定要重写hashCode方法（Item 11）。<br>不要让equals方法试图太聪明。如果只是简单的检测用于相等的属性，是不难遵守equals规范的。如果你在寻找相等方面过于激进，很容易陷入困境。考虑任何形式的别名通常是个坏主意。例如，File类不应该尝试将引用的符号链接等同于同一文件对象。幸好，它没有这么做。<br>在equals声明中，不要将Object参数替换成其他类型。程序员编写一个看起来像这样的equals方法并且花费数小时来解释它为什么不能正常工作的情况不在少数：</p>
<pre><code>// Broken - parameter type must be Object !
    public boolean equals(MyClass o)&#123;
    ...
&#125;
</code></pre>
<p>问题在于该方法没有重写Object.equals方法，Object类的equals方法参数是Object类型，这样写只是重载了equals方法（Item 52）。即使除了正常的方法之外，提供这样一个“强类型”的equals方法也是不被接受的，因为它可以导致子类中的Override注解生成误报，提供不安全的错觉。</p>
<p>如本条款所示，使用Override注解将阻止你犯这个错误（Item 40）。这个equals方法不能编译，且错误信息将明确告诉你错了什么：</p>
<pre><code>//Still broken, but won&#39;t compile
@Override 
public boolean equals(MyClass o)&#123;
    ...
&#125;
</code></pre>
<p>  编写和测试equals（和hashCode）方法是乏味的，且结果代码很普通。手动编写和测试这些方法的一个完美替代是使用谷歌开源的AutoValue框架，该框架可以为你自动生成这些方法，只需在类上添加一个注解即可。大多数情况下，AotoValue框架生成的方法与你自己编写的方法基本相同。<br>  IDE也有生成equals和hashCode方法的能力，但是生成的源代码比使用AutoValue生成的代码更冗长、可读性更差，不会自动跟踪类中的更改，因此需要测试。也就是说，使用IDE生成equals和hashCode方法比手动编写它们更可取，因为IDE不会粗心犯错，但人会。<br>  总之，尽量不要重写equals方法，除非不得不这么做：多数情况下从Object类继承的实现完全是你想要的。如果你确实要重写equals方法，务必确保比较类中所有的重要字段，并且以保护equals规范的所有五项要求的方式比较它们。</p>

            </div>

            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/Effective-Java-3rd/">#Effective Java 3rd</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2019/02/19/%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E4%B9%9F%E8%A6%81%E9%87%8D%E5%86%99hashCode%E6%96%B9%E6%B3%95/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">Item-11 重写equals方法时也要重写hashCode方法</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2019/02/17/%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9try-with-resources%E8%80%8C%E9%9D%9Etry-finally/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Item-9 优先选择try-with-resources而非try-finally</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2018</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">Doggie</a>
            
        </div>
        
            <script async data-pjax
                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                
                
                    Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/local-search.js"></script>






<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/toc.js"></script>
        
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>

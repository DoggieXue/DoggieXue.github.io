<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SpringBoot集成WebSocket示例</title>
    <link href="/2022/03/20/SpringBoot%E9%9B%86%E6%88%90WebSocket%E7%A4%BA%E4%BE%8B/"/>
    <url>/2022/03/20/SpringBoot%E9%9B%86%E6%88%90WebSocket%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot应用启动流程源码分析</title>
    <link href="/2022/03/20/SpringBoot%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2022/03/20/SpringBoot%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBootApplication注解深度解析</title>
    <link href="/2022/03/20/SpringBootApplication%E6%B3%A8%E8%A7%A3%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/03/20/SpringBootApplication%E6%B3%A8%E8%A7%A3%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac系统安装OpenResty及使用</title>
    <link href="/2022/03/17/Mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85OpenResty%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/03/17/Mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85OpenResty%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://openresty.org/cn/installation.html">OpenResty官方安装文档</a>强烈推荐MacOS使用<a href="https://brew.sh/">homebrew</a>包管理工具安装 。但是，对于使用老版本Mac系统（如10.13.6）的用户来说不是很友好，安装过程可能会找不到各种依赖、变量等，不如手动编译源码安装OpenResty。<br>参考<a href="https://www.runoob.com/w3cnote/openresty-intro.html">Linux下安装OpenResty</a>在Mac上编译安装：</p><h1 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h1><p>安装OpenResty前确保当前机器有以下依赖库：<br>● perl 5.6.1+<br>● libreadline<br>● libpcre<br>● libssl</p><p>参考<a href="https://www.toutiao.com/i7064948180328202766/?group_id=7064948180328202766">Linux系统非root用户下安装Nginx</a>安装pcre和openssl即可。</p><h1 id="下载源码包、编译、安装"><a href="#下载源码包、编译、安装" class="headerlink" title="下载源码包、编译、安装"></a>下载源码包、编译、安装</h1><div class="code-wrapper"><pre><code class="hljs">wget https://openresty.org/download/openresty-1.19.3.2.tar.gztar xzvf openresty-1.19.3.2.tar.gz       # 解压cd openresty-1.19.3.2/ ./configuremake make install</code></pre></div><p>默认情况下程序会被安装到 &#x2F;usr&#x2F;local&#x2F;openresty 目录。<strong>该目录下的nginx目录就是独立的Nginx服务</strong>。</p><img src="/2022/03/17/Mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85OpenResty%E5%8F%8A%E4%BD%BF%E7%94%A8/1644593016315-29c058d3-c3ce-4b78-bc94-7c9906b05b29.png" class=""><h1 id="配置PATH环境变量"><a href="#配置PATH环境变量" class="headerlink" title="配置PATH环境变量"></a>配置PATH环境变量</h1><p>方便操作OpenResty，因为Nginx&#x2F;OpenResty发布包中并没有提供好的启动、停止脚本，配置完后，就可以在终端直接使用nginx命令了。</p><div class="code-wrapper"><pre><code class="hljs">vi ~/.zshrc#添加如下配置export PATH=/usr/local/openresty/nginx/sbin:$PATH</code></pre></div><h1 id="命令及参数详解"><a href="#命令及参数详解" class="headerlink" title="命令及参数详解"></a>命令及参数详解</h1><p>OpenResty 的原始启动命令为 nginx，其参数有-v、-t、-p、-c、-s 等，使用说明如下：</p><h2 id="v参数"><a href="#v参数" class="headerlink" title="-v参数"></a>-v参数</h2><p>表示查看Nginx版本</p><div class="code-wrapper"><pre><code class="hljs">➜  ~ nginx -vnginx version: openresty/1.13.6.2</code></pre></div><h2 id="c参数"><a href="#c参数" class="headerlink" title="-c参数"></a>-c参数</h2><p>指定一个Nginx配置文件来替换默认的Nginx配置文件</p><div class="code-wrapper"><pre><code class="hljs">#单独建一个目录，并在目录中创建logs和conf目录mkdir ~/Software/openresty/workcd ~/Software/openresty/workmkdir logs/ conf/</code></pre></div><p>在conf目录下，定义一个后缀为.conf的文件，文件内容如下</p><div class="code-wrapper"><pre><code class="hljs">worker_processes  1;error_log logs/error.log;events &#123;    worker_connections 1024;&#125;http &#123;    server &#123;        listen 8080;        location / &#123;            default_type text/html;            content_by_lua &#39;                ngx.say(&quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;)            &#39;;        &#125;    &#125;&#125;</code></pre></div><p>启动Nginx：</p><div class="code-wrapper"><pre><code class="hljs">#若在上一步新建的目录下：cd ~/Software/openresty/work#执行下面的命令启动➜  work nginx -p ./ -c conf/nginx.conf #若在其他目录，比如用户目录➜  ~ nginx -c ~/Software/openresty/work/conf/nginx.conf </code></pre></div><img src="/2022/03/17/Mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85OpenResty%E5%8F%8A%E4%BD%BF%E7%94%A8/1644594219385-db85a29b-01e6-4282-886b-29d19cb6d425.png" class=""><h2 id="p参数"><a href="#p参数" class="headerlink" title="-p参数"></a>-p参数</h2><p><strong>表示设置前缀路径</strong><br>“-p .&#x2F;”表示将当前目录作为前缀路径，也就是说-c后面指定的配置文件conf&#x2F;nginx.conf中，所用到的相对路径都加上这个前缀。<br>“-p .&#x2F;“ 等价于 “-p <code>pwd</code>&#x2F;“</p><h2 id="t参数"><a href="#t参数" class="headerlink" title="-t参数"></a>-t参数</h2><p><strong>表示测试Nginx配置文件语法是否正确</strong><br>若不能确定编写的Nginx配置文件语法的正确性，就使用-t参数，指定某个配置文件进行检测。不加配置文件路径，默认检测Nginx服务目录下的配置文件。</p><img src="/2022/03/17/Mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85OpenResty%E5%8F%8A%E4%BD%BF%E7%94%A8/1644594581627-4c4703be-d9f2-4a15-b49b-bdd8eeae324b.png" class=""><h2 id="s参数"><a href="#s参数" class="headerlink" title="-s参数"></a>-s参数</h2><p><strong>表示给Nginx进程发送信号，包含stop(停止)、reload（重新加载）</strong></p><div class="code-wrapper"><pre><code class="hljs">➜  ~ nginx -p ~/Software/openresty/work/ -c conf/nginx.conf -s reload➜  ~ ➜  ~ ps -ef|grep nginx                                                   0  1564     1   0 11:09下午 ??         0:00.00 nginx: master process nginx    -2  1565  1564   0 11:09下午 ??         0:00.00 nginx: worker process    0  2345     1   0 11:40下午 ??         0:00.01 nginx: master process nginx -p ./ -c conf/nginx.conf        -2  2833  2345   0 11:51下午 ??         0:00.00 nginx: worker process        501  2845   495   0 11:51下午 ttys000    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox nginx➜  ~ ➜  ~ ➜  ~ nginx -p ~/Software/openresty/work/ -c conf/nginx.conf -s stop  ➜  ~ ➜  ~ ps -ef|grep nginx    0  1564     1   0 11:09下午 ??         0:00.00 nginx: master process nginx    -2  1565  1564   0 11:09下午 ??         0:00.00 nginx: worker process    501  2882   495   0 11:52下午 ttys000    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox nginx➜  ~ </code></pre></div><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>终端下输入curl <a href="http://localhost:8080/">http://localhost:8080</a></p><div class="code-wrapper"><pre><code class="hljs">➜  ~ curl http://localhost:8080&lt;p&gt;Hello, World!&lt;/p&gt;➜  ~ </code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx/OpenResty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx常用命令及配置</title>
    <link href="/2022/02/18/Nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/02/18/Nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="启动、检查、重启及关闭命令"><a href="#启动、检查、重启及关闭命令" class="headerlink" title="启动、检查、重启及关闭命令"></a>启动、检查、重启及关闭命令</h1><div class="code-wrapper"><pre><code class="hljs">#假设Nginx的安装目录为/home/nginx/nginx/#启动命令/home/nginx/nginx/sbin/nginx -c /home/nginx/nginx/conf/nginx.conf#状态检查/home/nginx/nginx/sbin/nginx -t#重新加载配置/home/nginx/nginx/sbin/nginx -s reload#关闭#查询nginx主进程号 ps -ef | grep nginx#从容停止   kill -QUIT 主进程号#快速停止   kill -TERM 主进程号#强制停止   kill -9 主进程号#若nginx.conf配置了pid文件路径，如果没有，则在logs目录下kill -信号类型 &#39;/usr/local/nginx/logs/nginx.pid&#39;</code></pre></div><h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><h2 id="events事件驱动配置"><a href="#events事件驱动配置" class="headerlink" title="events事件驱动配置"></a>events事件驱动配置</h2><p>● use指令<br>● worker_connections指令<br>● accept_mutex指令</p><div class="code-wrapper"><pre><code class="hljs">events &#123;    use epoll;                                        #使用epoll类型的IO多路复用模型，性能比select高worker_connections 204800;        #Worker进程能够打开的最大并发连接数accept_mutex on;                            #各个Worker进程通过锁来获取新连接&#125;</code></pre></div><p>server虚拟主机配置</p><div class="code-wrapper"><pre><code class="hljs">server &#123;    listen    80;server_name admin.cloudxue.com;        #后台管理服务的域名前缀location / &#123;    default_type &#39;text/html&#39;;    charset utf-8;    echo &quot;this is admin server&quot;;&#125;&#125;server &#123;    listen    80;server_name file.cloudxue.com;        #文件服务的域名前缀location / &#123;    default_type &#39;text/html&#39;;    charset utf-8;    echo &quot;this is file server&quot;;&#125;&#125;server &#123;    listen    80 default;server_name cloudxue.com *.cloudxue.com;        #若未指定前缀，配置默认访问的虚拟主机location / &#123;    default_type &#39;text/html&#39;;    charset utf-8;    echo &quot;this is default server&quot;;&#125;&#125;</code></pre></div><p>多个虚拟主机之间根绝server_name匹配的优先级从高到低：<br>● 精确匹配<br>● 左侧通配符匹配<br>● 右侧通配符匹配<br>● 正则表达式匹配<br>● defalt_server：在listen指令后面如果带有default指令参数，表示默认的、最后兜底的虚拟主机。</p><h2 id="错误页面配置"><a href="#错误页面配置" class="headerlink" title="错误页面配置"></a>错误页面配置</h2><p>error_page指令，该指令可用于http、server、location、if in location等上下文。</p><div class="code-wrapper"><pre><code class="hljs">server &#123;    listen            80;server_name admin.cloudxue.com;        #后台管理服务的域名前缀root                 /usr/local/openresty/www;location / &#123;    default_type &#39;text/html&#39;;    charset utf-8;    echo &quot;this is admin server&quot;;&#125;#设置错误页面#error_page 404 /404.html;error_page 404 =200 /404.html            #防止404页面被劫持error_page 500 502 503 504 /50x.html;&#125;</code></pre></div><h2 id="长链接配置"><a href="#长链接配置" class="headerlink" title="长链接配置"></a>长链接配置</h2><div class="code-wrapper"><pre><code class="hljs">keepalive_timeout    75;                #长链接有效时长，0表示禁用长链接，默认75秒keepalive_requests    100;        #一条长链接上允许被请求的资源的最大数量，默认100</code></pre></div><h2 id="访问日志配置"><a href="#访问日志配置" class="headerlink" title="访问日志配置"></a>访问日志配置</h2><div class="code-wrapper"><pre><code class="hljs">access_log    path    [format    [buffer=size]    [gzip[=level]]    [flush=time]    [if=condition]];http &#123;#先定义日志格式，名为为    log_format  format_main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                    &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;#日志文件、日志访问格式access_log    logs/access_main.log format_main;&#125;</code></pre></div><h2 id="location路由规则配置"><a href="#location路由规则配置" class="headerlink" title="location路由规则配置"></a>location路由规则配置</h2><p>● 精确匹配：标记符号为<code>=</code><br>● 普通匹配：标记符号为<code>^~</code>。是Nginx默认的匹配类型，标记符号可以省略。如果一个URL命中多个普通匹配，则最长的location普通匹配获胜。<br>● 正则匹配：标记符号为<code>~</code>、 <code>~*</code>、 <code>!~</code>、 <code>!~*</code>。若配置文件中有多个正则匹配location，只要匹配到第一个正则类型的location就停止匹配。正则匹配与location规则定义在配置文件中的先后顺序强相关。<br>● 默认匹配：标记符号为<code>/</code>。通常用来配置默认静态页（index.html）。</p><h2 id="rewrite模块指令配置"><a href="#rewrite模块指令配置" class="headerlink" title="rewrite模块指令配置"></a>rewrite模块指令配置</h2><p>Nginx的rewrite模块即ngx_http_rewrite_module标准模块，默认安装的模块。主要功能是对URI进行重写，然后再一次进行location匹配或者直接进行30X重定向返回给客户端。</p><p>● set指令：用于向变量放值。当变量存在时就赋值，不存在时，先创建再赋值。创建后的可见范围为Nginx整个配置</p><div class="code-wrapper"><pre><code class="hljs">set    $variable    value#实例set    $a &quot;foo&quot;;set $b &quot;$a, $a&quot;;</code></pre></div><p>● rewrite指令：主要功能是重写URI。</p><div class="code-wrapper"><pre><code class="hljs">rewrite regrex replacement [flag];#实例location /download/ &#123;    rewrite ^/download/(.*)/video/(.*)$    /view/$1/mp3/$2.mp3/    last;rewrite ^/download/(.*)/audio/(.*)$    /view/$1/mp3/$2.rmvb/    last;return 404;&#125;location /view &#123;    echo &quot;uri: $uri &quot;;&#125;#访问如下地址curl http://demo.cloudxue.com/download/1/video/10#rewrite模块进行匹配后，占位变量$1的值为1， $2的值为10uri: /view/1/mp3/10.mp3</code></pre></div><p>如果同一个上下文中出现多个rewrite指令，匹配会按照rewrite指令出现的顺序先后依次进行下去，匹配成功后并不会终止，而是继续往下匹配，知道返回最后一个匹配为止。可以通过指令参数flag控制是否中途停止匹配，假设在location上下文中：<br>  ○ last：停止rewrite匹配，使用当前计算后的新URI进行location匹配和跳转。<br>  ○ break：停止rewrite匹配，但是不进行location跳转。<br>  ○ redirect：外部重定向，返回302响应码<br>  ○ permanent：服务器将新URI地址返回给客户端浏览器，并返回301响应码给客户端，客户端使用新地址再发一次请求（地址栏会变）<br>注意事项:<br>● last和break的区别仅仅发生在location上下文中，如果发生在server上下文，那么last和break的作用是一样的。<br>● location上下文中的rewrite指令使用last指令参数会再次以新的URI重新发起内部重定向，再次进行location匹配，而新的URI若和旧的URI一样，会发生死循环。当循环发生到第10次时，Nginx会终止这样无意义的循环，并返回500错误。</p><p>● if指令：相当于引入了一个新的上下文作用于，适用于server、location两个上下文。</p><div class="code-wrapper"><pre><code class="hljs">if (condition) &#123;...&#125;#实例location /if_demo &#123;if ($http_user_agent ~*&quot;Firefox&quot;) &#123;     #匹配Firefox浏览器    return 403;&#125;if ($http_user_agent ~*&quot;Chrome&quot;) &#123;       #匹配Chrome浏览器    return 301;&#125;if ($http_user_agent ~*&quot;iphone&quot;) &#123;       #匹配iPhone手机    return 302;&#125;if ($http_user_agent ~*&quot;android&quot;) &#123;     #匹配安卓手机    return 404;&#125;return 405;                                                        #其他浏览器默认规则&#125;</code></pre></div><p>● return指令：可用于server、location、if上下文中，执行阶段是rewrite阶段。</p><div class="code-wrapper"><pre><code class="hljs">#格式1：返回响应的状态码和提示文字，提示文字可选return code [text];#格式2：返回响应的重定向状态码和重定向URLreturn code URL;#格式3：返回响应的重定向URL，默认的返回状态码是临时重定向302return URL;</code></pre></div><p>● add_header指令：设置返回客户端的响应。<br>使用Ajax进行跨域请求时，浏览器会向跨域资源的服务端发送一个OPTION请求，用于判断实际请求是否安全或者判断服务端是否允许跨域访问，这种请求也叫预检请求。跨域访问的预检请求是浏览器自动发出的，用户程序不知情，如果不进行特殊的配置，那么客户端发出一次请求，在服务端会收到两个请求：一个是预检请求，一个是正式的请求。会比较影响性能，通常Nginx代理服务器对预检请求进行拦截，同时对预检请求设置比较长时间的有效期。</p><div class="code-wrapper"><pre><code class="hljs">add_header Cache-Control no-store;add_header Content-Encoding gzip;add_header Content-Type &#39;text/html; charset=utf-8&#39;;#实例upstream zuul &#123;    server &quot;192.168.233.122:7799&quot;;keepalive 1000;&#125;server &#123;    listen      80;server_name    nginx.server *.nginx.server;default_type &#39;text/html&#39;;charset utf-8;#转发到上游服务器，但是‘OPTIONS’请求直接返回空location / &#123;    add_header    Access-Control-Max-Age 1728000;        #指定本次预检请求的有效期，单位秒，允许缓存该条回应20天，此期间内客户端不用发出另一条预检请求    add_header    Access-Control-Allow-Origin    *;    add_header    Access-Control-Allow-Credentials    true;    add_header    Access-Control-Allow-Methods    &#39;GET, POST, OPTIONS&#39;;    add_header    Access-Control-Allow-Headers    &#39;Keep-Alive, User-Agent, X-Requested-With, \    If-Modified-Since, Cache-Control, COntent-Type,token&#39;;    return 204;&#125;proxy_pass    http://zuul/;&#125;</code></pre></div><p>● 指令的执行顺序：与Nginx的请求处理的11各阶段有密切关系。其中3个比较常见的按照执行时的先后顺序依次是rewrite阶段、access阶段、content阶段。Nginx的配置指令一般只会注册并运行在其中的某一个处理阶段，比如set指令就是在rewrite阶段运行的，而echo指令只会在content阶段运行，在一次请求处理流程中，rewrite阶段总是在content阶段之前执行。</p><div class="code-wrapper"><pre><code class="hljs">location /sequence_demo &#123;    set $a foo;echo $a;set $a bar;echo $a;&#125;#访问测试：curl http://cloudxue.com/sequence_demo #响应bar bar#若按照请求处理阶段的先后次序排序location /sequence_demo &#123;    #rewrite 阶段的配置指令，执行在前面set $a foo;set $a bar;#content阶段的配置指令，执行在后面echo $a;echo $a;&#125;#所以以上输出为 bar bar</code></pre></div><h1 id="反向代理与负载均衡配置"><a href="#反向代理与负载均衡配置" class="headerlink" title="反向代理与负载均衡配置"></a>反向代理与负载均衡配置</h1><h2 id="proxy-pass反向代理指令"><a href="#proxy-pass反向代理指令" class="headerlink" title="proxy_pass反向代理指令"></a>proxy_pass反向代理指令</h2><p>位于ngx_http_proxy_module模块，注册在HTTP请求11个阶段的content阶段。<br>● 不带location前缀的代理：proxy_pass指令后面的目标URL格式为：”协议” + “IP[:PORT]” + “&#x2F;“，最终的代理URL不带location前缀。<br>● 带location前缀的代理：proxy_pass指令后面的目标URL格式未：”协议” + “IP[:PORT]” ，最终的代理URL带有location前缀。<br>● 带部分URI路径的代理：最终的代理URL为配置项中的目标URL前缀+请求URI中去掉location中前缀的剩余部分。</p><div class="code-wrapper"><pre><code class="hljs">worker_processes  1;error_log logs/error.log;events &#123;    worker_connections 1024;&#125;http &#123;    server &#123;            listen 8080;        server_name localhost;        default_type &#39;text/html&#39;;        charset utf-8;        location / &#123;            echo &quot;-uri=$uri&quot;                &quot;-host=$host&quot;                &quot;-remote= $remote_addr&quot;                &quot;-proxy_add_x_forwarded= $proxy_add_x_forwarded_for&quot;                &quot;-http_x_forwarded_for= $http_x_forwarded_for&quot;;        &#125;    &#125;        server &#123;        listen 80;        server_name localhost;        default_type &#39;text/html&#39;;        charset utf-8;        location / &#123;            echo &quot;默认根路径匹配:/&quot;;        &#125;        #不带location前缀的代理类型            location /foo_no_prefix &#123;                proxy_pass http://127.0.0.1:8080/;            &#125;        #带location前缀的代理类型        location /foo_prefix &#123;            proxy_pass http://127.0.0.1:8080;        &#125;        #带部分URI路径的代理        location /foo_uri_1 &#123;            proxy_pass http://127.0.0.1:8080/contextA/;        &#125;        #带部分URI路径的代理        location /foo_uri_2 &#123;            proxy_pass http://127.0.0.1:8080/context-A;        &#125;        &#125;    &#125;</code></pre></div><p>测试结果如下</p><div class="code-wrapper"><pre><code class="hljs">➜  ~ curl http://127.0.0.1/foo_no_prefix/bar.html-uri=/bar.html -host=127.0.0.1 -remote= 127.0.0.1 -proxy_add_x_forwarded= 127.0.0.1 -http_x_forwarded_for= ➜  ~ curl http://127.0.0.1/foo_prefix/bar.html -uri=/foo_prefix/bar.html -host=127.0.0.1 -remote= 127.0.0.1 -proxy_add_x_forwarded= 127.0.0.1 -http_x_forwarded_for= ➜  ~ curl http://127.0.0.1/foo_uri_1/bar.html-uri=/contextA/bar.html -host=127.0.0.1 -remote= 127.0.0.1 -proxy_add_x_forwarded= 127.0.0.1 -http_x_forwarded_for= ➜  ~ curl http://127.0.0.1/foo_uri_2/bar.html-uri=/context-A/bar.html -host=127.0.0.1 -remote= 127.0.0.1 -proxy_add_x_forwarded= 127.0.0.1 -http_x_forwarded_for= ➜  ~ </code></pre></div><h2 id="proxy-set-header请求头设置指令"><a href="#proxy-set-header请求头设置指令" class="headerlink" title="proxy_set_header请求头设置指令"></a>proxy_set_header请求头设置指令</h2><p>在反向代理前，proxy_set_header指令能重新定义添加字段传递给代理服务的请求头。请求头的值可以包含文本、变量和它们的组合，格式如下</p><div class="code-wrapper"><pre><code class="hljs">proxy_set_header head_field field_value;</code></pre></div><p>该指令在发生反向代理之前，将保持在内置变量$remote_addr中的真实客户端地址保持到请求头中，通常请求头参数名为X-real-ip。<br>在Java端可以使用request.getHeader(“X-real-ip”)获取请求头的值，就可以拿到客户的真实IP。</p><p>由于在整个请求处理链条上可能不仅一次反向代理，可能会经过N次反向代理，为了获取整个转发记录，可以使用$proxy_add_x_forwarded_for内置变量，该值的第一个就是真实地址<br>为了不丢失信息，反向代理的设置如下：</p><div class="code-wrapper"><pre><code class="hljs">location /hello &#123;    proxy_pass http://127.0.0.1:8080;proxy_set_header Host $host;proxy_set_header X-real-ip $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_redirect off; #修改从上游被代理服务器传来的应答头中的Location和Refresh字段&#125;</code></pre></div><p>以上配置，设置了Host、X-real-ip、X-Forwarded-For，分别将当前的目标主机、客户端IP、转发记录保存在请求头中。<br>当上游服务器返回的响应码是重定向301或者刷新302请求时，proxy_redirect指令可以重设HTTP头部的location或refresh字段值，off参数表示禁止所有的proxy_redirect指令，即反向代理时，禁止重定向。</p><h2 id="upstream上游服务器组"><a href="#upstream上游服务器组" class="headerlink" title="upstream上游服务器组"></a>upstream上游服务器组</h2><p>作为Nginx的一大特色，若没有负载均衡，只有反向代理，那么其使用价值会大打折扣。Nginx在配置反向代理时，可以通过负载均衡机制配置一个上有服务器组。当组内某台机器宕机时，仍能维持系统可用，从而实现高可用。</p><p>Nginx的负载均衡配置主要用到upstream指令，其格式为：</p><div class="code-wrapper"><pre><code class="hljs">upstream name &#123;    server name address [parameters];&#125;#上下文为http配置快，内部使用server指令定义组内的上游候选服务器</code></pre></div><p>配置示例：</p><div class="code-wrapper"><pre><code class="hljs">upstream zuul &#123;#名为upstream_zuul的共享内存区，大小为64k    zone upstream_zuul 64k;#组内该机器的权重为5，最大并发连接数为500server &quot;192.168.223.121:7799&quot; weight=5 max_conns=500;#组内该机器的默认权重为1，同时设置20秒内失败2次，判定该服务器不可用server &quot;192.168.233.122:7799&quot; fail_timeout=20s max_fails=2;#后备服务server &quot;192.168.233.123:7799&quot; backup;&#125;</code></pre></div><p>upstream的负载分配方式<br>● 加权轮询：默认负载方式，组内各服务器的权重默认为1，且上游各服务器的weight值相同，表示每个请求按到达的先后顺序逐一分配到不同的上游服务器，若果某个上游服务器宕机，就自动剔除。<br>● hash指令：基于hash函数值进行负载均衡，hash函数的key可以包含文本、变量或二者的组合。是一个独立的指令，通常与consistent参数搭配使用，避免组中某台机器宕机后，原来的大多数key可能会寻址到不同的server上。使用consistent参数，则hash一致性将选择Ketama算法，从而只有少数key会重新映射到其他server上，即大多数key不受server宕机的影响，还走原来的server，这对高缓存server命中率有很大帮助。配置示例如下：</p><div class="code-wrapper"><pre><code class="hljs">upstream backend &#123;#通过请求的$request_uri的hash值进行负载均衡    hash $request_uri    consistent;server 192.168.233.121;server 192.168.233.122;server 192.168.233.123;&#125;</code></pre></div><p>● ip_hash指令：基于客户端的IP的hash值进行负载均衡，这样每个客户端固定访问同一个后端服务器，可以解决类似session不能跨服务器的问题。如果上游server不可用，就需要手工摘除或者配置down参数。是一个独立的指令。配置示例如下：</p><div class="code-wrapper"><pre><code class="hljs">upstream backend &#123;    ip_hash;server 192.168.233.121;server 192.168.233.122;server 192.168.233.123;&#125;</code></pre></div><h1 id="高阶指令"><a href="#高阶指令" class="headerlink" title="高阶指令"></a>高阶指令</h1><h2 id="limit-req-zone指令与limit-req指令："><a href="#limit-req-zone指令与limit-req指令：" class="headerlink" title="limit_req_zone指令与limit_req指令："></a>limit_req_zone指令与limit_req指令：</h2><p>以上两个指令使用漏桶算法进行限流。<br>● limit_req_zone：定义一个限流的具体规则<br>● limit_req：使用limit_req_zone定义的限流规则</p><div class="code-wrapper"><pre><code class="hljs">#通过limit_req_zone定义限流规则    #定义每个IP的访问为6次/分钟，zone指定限流关键词计数存储的共享空间    limit_req_zone  $binary_remote_addr zone=perip:10m  rate=6r/m;    #定义每台server的访问限速为 10次/秒    limit_req_zone  $server_name    zone=perserver:1m   rate=10r/m;    server &#123;        listen  8080;        server_name localhost;        default_type    &#39;text/html&#39;;        charset utt-8;                #brust属性指定爆发请求数，是的Nginx具备一定的突发流量处理能力，默认使用limit_req_zone中定义的rate来处理爆发请求        limit_req   zone=perip brust=2000 nodelay;        limit_req   zone=perserver;        location /nginx/ratelimit/demo &#123;            echo    &quot;-uri= $uri  -remode_addr= $remote_addr&quot;                    &quot;-server_name= $server_name&quot;;        &#125;    &#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx/OpenResty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx/OpenResty理论基础</title>
    <link href="/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>Nginx是一个高性能的HTTP和反向代理服务器，生产场景中几乎都会用到，利用Nginx+Lua可以实现高并发编程。<br>Nginx有以下三个社区分支：<br>● Nginx官方：更新迭代快，提供免费版和商业版。<br>● Tengine：是由淘宝网发起的Web服务器项目。在Nginx的基础上针对大访问量网站的需求添加了很多高级的特性和功能。<br>● OpenResty：将LuaJIT VM 嵌入Nginx中，实现了OpenResty这个高性能服务端解决方案。OpenResty是一个基于Nginx和Lua的高性能Web平台，其内部集成了大量精良的Lua库，第三方模块以及大多数的依赖项，用于方便地搭建能够处理超高并发、扩展性极高的动态Web应用、Web服务和动态网关。</p><p>OpenResty的目标是让Web服务直接跑在Nginx服务内部，充分利用Nginx的非阻塞I&#x2F;O模型，不仅对HTTP客户端请求，甚至对远程后端（MySQL、PostgreSQL、memcached及Redis）都进行一致的高性能响应。<br>OpenResty通过汇聚各种设计精良的Nginx模块，从而将Nginx有效地变成了强大的通用Web应用平台，使得Web开发工程师和系统开发工程师可以使用Lua脚本语言调用Nginx支持的各种C及Lua模块，快速构造出足以胜任10KB乃至1000KB以上单机并发连接的高性能Web应用系统。</p><h1 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h1><p>两者都是代理服务中，进行客户端请求的转发</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>客户端非常明确要访问的服务器地址，客户端需要配置目标服务器的IP和端口信息。一般来说，正向代理服务器是一台和客户端网络连通的局域网内部的机器或者是可以打通两个隔离网络的双网卡机器。通过正向代理，客户端的HTTP请求可以转发到之前与客户端网络不通的其他不同的目标服务器。<br>正向代理的主要场景是客户端。由于网络不通等物理原因，需要通过正向代理服务器这种中间转发环节顺利访问目标服务器，也可以通过正向代理服务器对客户端某些信息进行一些伪装和改变。</p><img src="/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1645099365279-7c2cbd04-5290-4eae-bd13-41dbd1824650.png" class=""><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>客户端不知道目标服务器的信息，代理服务器就像是原始的目标服务器，客户端不需要进行任何特别的设置。反向代理最大的特点是客户端不知道目标服务器地址。<br>反向代理的主要场景是服务端。服务提供方可以通过反向代理服务器轻松实现目标服务器的动态切换，实现多目标服务器的负载均衡等。</p><img src="/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1645099413705-712ae104-c6c4-4715-acd3-1efebbad69df.png" class=""><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正向代理（如Squid、Proxy）是对客户端的伪装，隐藏了客户端的IP、头部或者其他信息，服务器得到的伪装过的客户端信息；<br>反向代理（如Nginx、Apache）是对目标服务器的伪装，隐藏了目标服务器的IP、头部或者其他信息，客户端得到的是伪装过的目标服务器信息。</p><h1 id="Nginx核心原理"><a href="#Nginx核心原理" class="headerlink" title="Nginx核心原理"></a>Nginx核心原理</h1><p>Nginx的核心原理包括Reactor模型、Nginx的模块化设计、Nginx的请求处理阶段。</p><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p>Nginx对高并发IO的处理使用了Reactor事件驱动模型。该模型的基本组件有<br>● 事件收集器：负责收集worker进程的各种I&#x2F;O请求。<br>● 事件发送器：负责将IO事件发送到事件处理器。<br>● 事件处理器：负责各种事件的响应工作。</p><p><strong>Reactor模型的核心思想是</strong>：基于操作系统提供的多路I&#x2F;O复用技术，将所有要处理的I&#x2F;O事件注册到一个中心I&#x2F;O多路复用器上，同时主线程阻塞在多路复用器上，一旦有I&#x2F;O事件到来或者准备就绪(文件描述符或Socket可读、写)，多路复用器返回并将事先注册的相应I&#x2F;O事件分发到对应的处理器中。</p><h2 id="Nginx的两类进程"><a href="#Nginx的两类进程" class="headerlink" title="Nginx的两类进程"></a>Nginx的两类进程</h2><p>Nginx启动后会以daemon方式在后台运行，其后台有两类进程：<br>● <strong>Master</strong>进程：又叫管理者进程。主要负责调度Worker工作进程，比如加载配置文件、启动工作进程、接收来自外界的信号、向各Worker进程发送信号、监控Worker进程的运行状态等。同时负责创建监听套接字接口，交由Worker进程进行监听。<br>● <strong>Worker</strong>进程：又叫工作进程。主要用来处理网络事件，当一个Worker进程在接收一个连接通道后，就开始读取请求、解析请求、处理请求，处理完成产生数据后，再返回给客户端，最后断开连接通道。各Worker进程之间是对等且独立的，它们同等竞争来自客户端的请求，一个请求只能在一个Worker进程中处理。</p><h2 id="Nginx的模块化设计"><a href="#Nginx的模块化设计" class="headerlink" title="Nginx的模块化设计"></a>Nginx的模块化设计</h2><p>高度模块化的设计是Nginx的架构基础。各模块之间严格遵循“高内聚、低耦合”的原则。在Nginx实现中，一个模块包含一系列命令（cmd）和这些命令相对应的处理函数（cmd-&gt;handler）。Nginx的Worker进程在执行过程中会通过配置文件的配置指令定位到对应的功能模块的某个命令，然后调用命令对应的处理函数来完成相应的处理。<br>Nginx的模块结构图：</p><img src="/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1645100303761-ebe6a415-a624-4a6c-bd49-5f67ce5e4915.png" class=""><p>Nginx的主要模块说明：<br>● Core核心模块：是Nginx服务器正常运行必不可少的模块，提供错误日志记录、配置文件解析、Reactor事件驱动机制、进程管理等核心功能。<br>● 标准HTTP模块：主要提供HTTP协议解析相关的功能，比如端口配置、网页编码设置、HTTP响应头设置等。<br>● 可选HTTP模块：主要用于扩展标准的HTTP功能，让Nginx能处理一些特殊的服务，如Flash多媒体传输、网络传输压缩、安全协议SSL的支持。<br>● 邮件服务模块：主要用于支持Nginx的邮件服务，包括对POP3协议、IMAP协议和SMTP协议的支持。<br>● 第三方模块：为了扩展Nginx服务器功能，定制开发的，如JSON支持、Lua支持。</p><h2 id="Nginx配置文件上下文结构"><a href="#Nginx配置文件上下文结构" class="headerlink" title="Nginx配置文件上下文结构"></a>Nginx配置文件上下文结构</h2><p>Nginx配置文件包含若干配置项，每个配置项由配置指令和指令参数两部分组成。<br>Nginx的配置项的具体功能与其所处的作用域（上下文、配置块）是强相关的。Nginx指令的作用域配置块大致分为5种，其层次关系如图：</p><img src="/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1645100554585-c8477054-2a67-4405-a2d2-b49f84dbd1d5.png" class=""><p>一个标准的Nginx基本配置文件nginx.conf上下文结构如下：</p><div class="code-wrapper"><pre><code class="hljs">... #main全局配置快，可配置工作进程数events &#123; #事件处理模型配置块，例如IO读写模型、连接数等    ...  &#125;http &#123; #http协议配置块    ... #http协议的全局配置快server &#123; #虚拟服务配置块1        location [PATTERN] &#123; #路由规则配置快1        ...    &#125;        location [PATTERN] &#123; #路由规则配置快2        ...    &#125;&#125;server &#123; #虚拟服务配置块2    ...&#125;... #其他http协议的全局配置&#125;main &#123;    #mail服务配置块    ...     #email相关协议，如SMTP、IMAP、POP3等&#125;</code></pre></div><p>除了基本配置文件外，Nginx还有如下配置文件：<br>● mime.type：与MIME类型相关的配置文件<br>● fastcgi.conf：与FastCGI相关的配置文件。<br>● proxy.conf：与Proxy相关的配置文件。<br>● sites.conf：单独配置Nginx的提供的虚拟主机。</p><h2 id="Nginx的请求处理流程"><a href="#Nginx的请求处理流程" class="headerlink" title="Nginx的请求处理流程"></a>Nginx的请求处理流程</h2><p>Nginx中HTTP请求的处理流程可以分为4步：</p><ol><li>读取解析请求行；</li><li>读取解析请求头；</li><li>多阶段处理，即执行handle处理器列表；</li><li>将结果返回给客户端<br>Nginx把HTTP请求处理划分成了11个阶段，在完成前两步处理后，Nginx将整个请求封装到一个请求结构体ngx_http_request_t实例中，该实例相当于一个Java对象，然后进入多阶段处理，执行handler处理器列表，列表中的每个handler处理器都会对请求对象进行处理，类似于Netty中的PipeLine。</li></ol><p>在Nginx进行多阶段处理时，handler处理器的执行次序除了和配置文件中对应指令的配置顺序相关外，还和指令所处的阶段先后次序相关。如下如展示了多阶段处理的顺序：</p><img src="/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/c063ac3fcb254d778b847ac771a7dfe6.jpeg" class=""><h2 id="HTTP请求处理的11个阶段"><a href="#HTTP请求处理的11个阶段" class="headerlink" title="HTTP请求处理的11个阶段"></a>HTTP请求处理的11个阶段</h2><ol><li>post-read阶段：标准模块的ngx_realip处理器就注册在该阶段。改写请求的来源地址，将客户端真实IP附加上，便于后端获取。</li><li>server-rewrite阶段：server块中请求地址重写阶段。</li><li>find-config阶段：配置查找阶段，根据请求URL地址去匹配location路由表达式。不支持Nginx模块注册处理程序。</li><li>rewrite阶段：请求地址重写阶段，此时，location配置块中的指令开始起作用，如breaker、if、return、rewrite、set等，三方库ngx_lua模块中的set_by_lua、rewrite_by_lua指令也注册在此阶段.</li><li>post-rewrite阶段：请求地址URI重写后提交阶段，防止递归修改URI造成死循环。不支持Nginx模块注册处理程序。</li><li>preaccess阶段：访问权限检查准备阶段。</li><li>access阶段：访问权限检查阶段。注册在该阶段的指令有ngx_http_access_module模块的指令、三方ngx_auth_request模块的指令、ngx_lua模块的指令。特别提醒：echo指令用于返回内容，在location上下文中，该指令注册在content阶段，access阶段不执行该指令的配置项。</li><li>post-access阶段：访问权限检查提交阶段。如果请求不被允许访问Nginx服务器，该阶段负责向用户返回错误响应。不支持Nginx模块注册处理程序。在access阶段可能存在多个访问控制模块的指令注册，该阶段    的satisfy指令可以用于控制它们的协作方式：<br>  a. 逻辑或操作：satisfy any。表示访问控制模块A、B、C或更多，只要其中任意一个通过就算通过。<br>  b. 逻辑与操作：satisfy all。表示访问控制模块A、B、C或更多，全部通过才算通过。</li><li>try-files阶段：可以使请求按顺序访问多个静态文件资源，直到某个静态文件资源符合条件。不支持Nginx模块注册处理程序。</li><li>content阶段：内容产生阶段，大部分HTTP模块会介入。Nginx的echo、ngx_lua中的content_by_lua指令就注册在该阶段</li><li>log阶段：日志记录模块。</li></ol><p>Nginx将一个HTTP请求分为11个处理阶段，这样做让每个HTTP模块可以只专注于完成一个独立、简单的功能。而一个请求的完整处理过程由多个HTTP模块共同完成，可以极大地提高多个模块合作的协同性、可测试性和可扩展性。<br>同一个阶段内的指令，Nginx会按照各个指令的上下文顺序执行对应的handle处理器方法。</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx/OpenResty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot对SpringMVC的整合原理</title>
    <link href="/2020/01/26/SpringBoot%E5%AF%B9SpringMVC%E7%9A%84%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86/"/>
    <url>/2020/01/26/SpringBoot%E5%AF%B9SpringMVC%E7%9A%84%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>传统的Java Web项目通常要有部署描述符(web.xml)，在部署描述符中定义我们需要的Servlet、Filter、Listener，且部署描述符必须位于WEB-INF&#x2F;目录下。其实，这都是Servlet3.0以前的版本（Servlet2.5）的规范所要求的。随着Servlet3.0规范对注解的使用，web.xml配置文件被代替，SpringBoot框架就是以Servlet 3.0规范作为支撑，消除了对web.xml的使用。</p><h1 id="操作机制"><a href="#操作机制" class="headerlink" title="操作机制"></a>操作机制</h1><p>Servlet 3.0的<code>ServletContainerInitializer</code>被设计成支持基于代码的servlet容器配置。SpringBoot框架中提供了<code>SpringServletContainerInitializer</code>类来实现<code>ServletContainerInitializer</code>接口，同时使用Spring的<code>WebApplicationInitializer</code> SPI来消除web.xml或者同web.xml搭配使用。</p><h2 id="单独使用时："><a href="#单独使用时：" class="headerlink" title="单独使用时："></a>单独使用时：</h2><p><code>SpringServletContainerInitializer</code>类会被加载和实例化，且其onStart方法会被任何兼容Servlet 3.0的容器在容器启动时调用，前提是spring-web模块jar包在当前servlet容器的类路径中。这一切通过Jar Service API的<code>ServiceLoader.load(Class)</code>方法，寻找<code>spring-web</code>模块中<code>META-INF/services/javax.servlet.ServletContainerInitializer</code>服务提供配置文件来实现的。</p><h2 id="与web-xml搭配使用时："><a href="#与web-xml搭配使用时：" class="headerlink" title="与web.xml搭配使用时："></a>与web.xml搭配使用时：</h2><p>web应用可以在启动时选择限制类路径中扫描servlet容器的数量；或者<br>通过web.xml中<code>metadata-complete</code>属性来控制servlet注解的扫描；或者<br>通过web.xml中<code>&lt;absolute-ordering&gt;</code>元素来控制web片段执行SCI扫描</p><h1 id="SpringServletContainerInitializer与WebApplicationInitializer之间的关系"><a href="#SpringServletContainerInitializer与WebApplicationInitializer之间的关系" class="headerlink" title="SpringServletContainerInitializer与WebApplicationInitializer之间的关系"></a>SpringServletContainerInitializer与WebApplicationInitializer之间的关系</h1><p>Spring的<code>WebApplicationInitializer SPI</code>仅有一个方法：<code>WebApplicationInitializer.onStart(ServletContext)</code>。该方法签名有意的类似<code>ServletContainerInitializer.onStart(Set, ServletContext)</code>方法。简单来说，<code>SpringServletContainerInitializer</code>负责实例化，并且将<code>ServletContext</code>委托给任何用户定义的<code>WebApplicationInitializer</code>实现。接下来每一个<code>WebApplicationInitializer</code>(实现)负责实例化实际的<code>ServletContext</code>。因为<code>SpringServletContainerInitializer</code>声明了<br><code>@HandleType(WebApplicationInitializer.class)</code>，<br>Servlet 3.0+的容器将会自动地扫描类路径中对<code>Spring的WebApplicationInitializer</code>接口的实现类，并将所有实现类的class对象(<code>webAppInitializerClasses</code>)组成的集合作为<code>onStart</code>方法的第一个参数。若在类路径中未找到<code>WebApplicationInitializer</code>的实现类，onStart方法不会做任何操作。一条INFO级别的日志信息将会被打印出来通知用户：<code>ServletContainerInitializer</code>已经被调用了，但是未找到<code>WebApplicationInitializer</code>实现。</p><div class="code-wrapper"><pre><code class="hljs">if (initializers.isEmpty()) &#123;    servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);    return;&#125;</code></pre></div><p>假设在类路径中发现了一个或多个<code>WebApplicationInitializer</code>类型的实现类，接下来他们会被实例化（如果被<code>@Order</code>注解定义，则会按照顺序实例化）。然后<code>WebApplicationInitializer.onStart(ServletContext)</code>方法将会在每一个实例上被调用。委托<code>ServletContext</code>给每一个实例，，注册并配置<code>servlet</code>（例如Spring的<code>DispatcherServlet</code>），<code>listener</code>(例如Spring的<code>ContextLoaderListener</code>)，或者任何其他<code>Servlet API</code> 组件，比如说<code>filter</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用非root用户停止和启动Apache、Nginx的方法</title>
    <link href="/2019/12/31/%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%81%9C%E6%AD%A2%E5%92%8C%E5%90%AF%E5%8A%A8Apache%E3%80%81Nginx%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2019/12/31/%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%81%9C%E6%AD%A2%E5%92%8C%E5%90%AF%E5%8A%A8Apache%E3%80%81Nginx%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Apache或Nginx运行时会监听80或者443端口，root权限被回收后，修改配置文件需要重启的情况下，可以通过给二进制文件set UID的方式实现。</p><h1 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h1><p>root用户登录进入到&#x2F;opt&#x2F;apache&#x2F;bin目录下</p><div class="code-wrapper"><pre><code class="hljs"># cd /opt/apache/bin# chown root httpd# chmod u+s httpd# su - chatweb$ ll httpd -rwsr-xr-x 1 root chatweb 1546353 2017-08-14 httpd$ /opt/apache/bin/apachectl start</code></pre></div><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>root用户进入&#x2F;…&#x2F;nginx&#x2F;sbin目录下</p><div class="code-wrapper"><pre><code class="hljs"># cd /.../nginx/sbin# chown root nginx# chmod u+s nginx# su - nginx$ ll nginx-rwsr-xr-x 1 root nginx 3289160 2019-05-05 nginx$ /.../nginx/sbin/nginx -s reload</code></pre></div><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Linux系统中的文件除了user id和group id外，还有俩称之为effective的id，四个id简写为uid、gid和euid、egid。<br>内核主要是根据euid和egid来确定进程对资源的访问权限：</p><ul><li>一个进程如果没有SUID或SGID位，则euid&#x3D;uid egid&#x3D;gid，分别是运行这个程序的用户的uid和gid；  </li><li>如果一个程序设置了SUID，则euid和egid变成被运行的程序的所有者的uid和gid；  </li><li>SUID的优先级比SGID高，当一个可执行程序设置了SUID，则SGID会自动变成相应的egid</li></ul><p>set UID（SUID）的作用是让执行该命令的用户以该命令拥有者的权限去执行。假如启动命令的拥有者是root用户，普通用户执行命令时就会拥有root的权限，然后使用root权限去操作服务。<br>set UID的方式只针对二进制文件，是在执行程序（程序的可执行位被设置）时起作用，而可执行位只对普通文件和目录文件有意义。</p><p>给文件加或去掉SUID和SGID的命令如下：</p><div class="code-wrapper"><pre><code class="hljs"># chmod u+s filename 设置SUID位# chmod u-s filename 去掉SUID设置# chmod g+s filename 设置SGID位# chmod g-s filename 去掉SGID设置</code></pre></div><p>如果一个文件被设置了SUID或SGID位，会分别表现在所有者或同组用户的权限的可执行位上。例如：<br>1、-rwsr-xr-x 表示SUID和所有者权限中可执行位被设置<br>2、-rwSr–r– 表示SUID被设置，但所有者权限中可执行位没有被设置<br>3、-rwxr-sr-x 表示SGID和同组用户权限中可执行位被设置<br>4、-rw-r-Sr– 表示SGID被设置，但同组用户权限中可执行位没有被设置</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Nginx</category>
      
      <category>Apache</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx/OpenResty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot可运行jar启动过程分析</title>
    <link href="/2019/12/18/SpringBoot%E5%8F%AF%E8%BF%90%E8%A1%8Cjar%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <url>/2019/12/18/SpringBoot%E5%8F%AF%E8%BF%90%E8%A1%8Cjar%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>通过maven或者gradle命令构建出来的可运行jar包解压后，在<code>META-INF/MANIFEST.MF</code>中<code>Main-Class</code>值为<code>org.springframework.boot.loader.JarLauncher</code><br>该类位于与<code>META-INF/</code>同目录的<code>org/springframework/boot/loader</code>目录中。经过对比发下，后者就是<code>spring-boot-loader-version.jar</code>包解压后的全部内容。</p><ul><li>打包可运行jar文件时，不能再jar中嵌套jar文件；</li><li>如果jar文件中嵌套jar文件，则该jar文件称为FatJar，需要自定义加载器才能使该FatJar可运行；</li><li>通过<code>java -jar spring-boot-loader-version.jar</code>命令运行SpringBoot打出的jar包时，根据jar运行机制，运行<code>MANIFEST.MF</code>中定义的<code>Main-Class</code>指定的类中的main方法，该类为<code>org.springframework.boot.loader.JarLauncher</code></li></ul><p>JarLauncher的继承结构如下</p><div class="code-wrapper"><pre><code class="hljs">@startumlabstract class Launcherabstract class ExecutableArchiveLauncherabstract class JarLauncherExecutableArchiveLauncher &lt;|-- JarLauncherLauncher&lt;|-- ExecutableArchiveLauncher@enduml</code></pre></div><p>JarLauncher中的main方法:</p><div class="code-wrapper"><pre><code class="hljs">public static void main(String[] args) throws Exception &#123;    (new JarLauncher()).launch(args);&#125;</code></pre></div><p>创建<code>JarLauncher</code>实例时，自己本身的无参构造方法未做任何事情，会先调用父类的无参构造方法：完成<code>Archive</code>对象的初始化，Archive对象就表示<code>spring-boot-loader-version.jar</code>在硬盘上的绝对物理路径。然后调用<code>Launcher</code>类中的<code>launch(String[] args)</code>方法：</p><div class="code-wrapper"><pre><code class="hljs">protected void launch(String[] args) throws Exception &#123;    JarFile.registerUrlProtocolHandler();    ClassLoader classLoader = createClassLoader(getClassPathArchives());    launch(args, getMainClass(), classLoader);&#125;</code></pre></div><p>该方法完成的主要事情就是：通过</p><div class="code-wrapper"><pre><code class="hljs">ClassLoader classLoader = createClassLoader(getClassPathArchives());</code></pre></div><p>创建自定义加载器<code>LauncherdURLClassLoader</code>,该加载器会将FatJar中<code>BOOT-INF/classes</code>和<code>BOOT-INF/lib</code>目录下的所有文件加载到系统类加载器(应用类加载器)中;</p><p>继续调用重写的launch方法:</p><div class="code-wrapper"><pre><code class="hljs">protected void launch(String[] args, String mainClass, ClassLoader classLoader)            throws Exception &#123;    Thread.currentThread().setContextClassLoader(classLoader);    createMainMethodRunner(mainClass, args, classLoader).run();&#125;</code></pre></div><p>首先通过</p><div class="code-wrapper"><pre><code class="hljs">Thread.currentThread().setContextClassLoader(classLoader);</code></pre></div><p>设置当前线程的上下文类加载器为之前创建的自定义加载器<code>LaunchedURLCLassLoader</code>；<br>然后创建<code>MainMethodRunner</code>实例，指定要运行的<code>mainClassName为MANIFEST.MF</code>中定义的<code>Start-Class</code>属性值，即<code>SpringBoot</code>启动类。<br>最后运行<code>run()</code>方法，使用反射机制运行<code>SpringBoot</code>启动类中的<code>main</code>方法。</p><div class="code-wrapper"><pre><code class="hljs">public void run() throws Exception &#123;    Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()                .loadClass(this.mainClassName);    Method mainMethod = mainClass.getDeclaredMethod(&quot;main&quot;, String[].class);    mainMethod.invoke(null, new Object[] &#123; this.args &#125;);&#125;</code></pre></div><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>使用gradle或者maven打出来的可运行jar包为一个FatJar；</li><li>FatJar中的启动类为<code>org.springframework.boot.loader.JarLauncher</code>，该类实际位于<code>spring-boot-loader-version.RELEASW.jar</code>辅助jar包中，实际打包成FatJar时，辅助jar包会被解压放到FatJar中，以便遵循jar规范，使其可运行；</li><li>运行<code>org.springframework.boot.loader.JarLauncher</code>中的<code>main</code>方法时，会创建自定义类加载器，加载FatJar中的<code>BOOT-INF/classes/</code>和<code>BOOT-INF/lib/</code>目录下的所有文件加载到系统类加载器(应用类加载器)中;</li><li>通过反射机制运行SpringBoot启动类中的main方法，来实现FatJar的运行。<h2 id="延伸："><a href="#延伸：" class="headerlink" title="延伸："></a>延伸：</h2></li><li>通过反射机制运行SpringBoot中的main方法时，传入的第一个参数是null:<br><code>mainMethod.invoke(null, new Object[] &#123; this.args &#125;);</code><br>这是因为定义的main方法是static的，类中的静态方法不归属于当前类，而是归属于当前类所对应的class对象,所以可以使用null，也可以使用任意对象。</li><li>既然使用的是反射机制来运行SpringBoot中启动类的方法，那么这个方法是否必须是main方法，答案是否定的，如果只是通过<code>java -jar</code>命令这种方式来SpringBoot应用，那么可以指定任意方法。此处默认使用main方法是为了开发时SpringBoot应用可以在IDE中运行。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统非root用户下安装Nginx</title>
    <link href="/2019/04/28/Linux%E7%B3%BB%E7%BB%9F%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/"/>
    <url>/2019/04/28/Linux%E7%B3%BB%E7%BB%9F%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/</url>
    
    <content type="html"><![CDATA[<p>通常使用Nginx或者Apache作为Web服务器时，默认监听80端口，因此默认会使用root用户去安装，而且，使用yum命令安装时，通常会安装到默认的路径下，默认路径通常是root用户才有执行权限的。如果不需要使用Nginx监听1024以下的端口，且对权限和网络管理比较严格时，能用非root权限解决的，就用普通用户。在此使用编译Nginx源码的方式安装Nginx。 假设已拿到root用户权限，但需要使用普通用户去管理Nginx。</p><h1 id="登录Linux服务器"><a href="#登录Linux服务器" class="headerlink" title="登录Linux服务器"></a>登录Linux服务器</h1><p>root登录服务器<br>    ssh <a href="mailto:&#x72;&#111;&#x6f;&#x74;&#64;&#120;&#46;&#120;&#46;&#120;&#46;&#120;">&#x72;&#111;&#x6f;&#x74;&#64;&#120;&#46;&#120;&#46;&#120;&#46;&#120;</a></p><h1 id="创建普通用户并设置密码"><a href="#创建普通用户并设置密码" class="headerlink" title="创建普通用户并设置密码"></a>创建普通用户并设置密码</h1><p>创建普通用户</p><div class="code-wrapper"><pre><code class="hljs"># useradd nginx</code></pre></div><p>为nginx用户设置密码为nginx#123</p><div class="code-wrapper"><pre><code class="hljs"># echo nginx#123|passwd --stdin nginx</code></pre></div><p>创建完毕用户后，切换到nginx用户</p><div class="code-wrapper"><pre><code class="hljs"># su nginx</code></pre></div><p>进入用户目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd ~</code></pre></div><h1 id="安装openssl"><a href="#安装openssl" class="headerlink" title="安装openssl"></a>安装openssl</h1><p><a href="https://www.openssl.org/source/">下载地址</a></p><p>进入用户目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd ~</code></pre></div><p>删除原有安装（如果有的话）</p><div class="code-wrapper"><pre><code class="hljs">$ rm -rf openssl$ rm -rf openssl-1.1.0j #（以机器上实际安装的为准）</code></pre></div><p>解压</p><div class="code-wrapper"><pre><code class="hljs">$ tar -zxv -f openssl-1.1.0j.tar.gz</code></pre></div><p>进入源码目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd openssl-1.1.0j</code></pre></div><p>配置<br>注意，prefix和opensslsir的值要写绝对路径，不能是相对路径，表示编译后的地址</p><div class="code-wrapper"><pre><code class="hljs">$ ./config --prefix=/home/nginx/openssl --openssldir=/home/nginx/openssl/conf</code></pre></div><p>编译安装</p><div class="code-wrapper"><pre><code class="hljs">$ make &amp;&amp; make install</code></pre></div><p>检查安装</p><div class="code-wrapper"><pre><code class="hljs">$ cd /home/nginx/openssl/bin$ openssl version -a</code></pre></div><h1 id="安装pcre"><a href="#安装pcre" class="headerlink" title="安装pcre"></a>安装pcre</h1><p>下载地址：<br><a href="https://sourceforge.net/projects/pcre/">https://sourceforge.net/projects/pcre/</a></p><p>进入安装目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd ~</code></pre></div><p>删除原有安装（如果有的话）</p><div class="code-wrapper"><pre><code class="hljs">$ rm -rf pcre$ rm -rf pcre-8.43 （以机器上实际安装的为准）</code></pre></div><p>解压</p><div class="code-wrapper"><pre><code class="hljs">$ tar -zxv -f pcre-8.43.tar.gz</code></pre></div><p>进入源码目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd pcre-8.43</code></pre></div><p>执行配置</p><div class="code-wrapper"><pre><code class="hljs">$./configure --prefix=/home/nginx/pcre/</code></pre></div><p>编译安装</p><div class="code-wrapper"><pre><code class="hljs">$ make &amp;&amp; make install</code></pre></div><h1 id="安装zlib"><a href="#安装zlib" class="headerlink" title="安装zlib"></a>安装zlib</h1><p>下载地址：<a href="http://zlib.net/">http://zlib.net/</a></p><p>进入安装目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd ~</code></pre></div><p>删除原有安装（如果有的话）</p><div class="code-wrapper"><pre><code class="hljs">$ rm -rf zlib$ rm -rf zlib-1.2.11（以机器上实际安装的为准）</code></pre></div><p>解压</p><div class="code-wrapper"><pre><code class="hljs">$ tar -zxv -f zlib-1.2.11.tar.gz</code></pre></div><p>进入源码目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd zlib-1.2.11</code></pre></div><p>配置</p><div class="code-wrapper"><pre><code class="hljs">$./configure --prefix=/home/nginx/zlib/</code></pre></div><p>编译安装</p><div class="code-wrapper"><pre><code class="hljs">$ make &amp;&amp; make install</code></pre></div><h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><p>下载地址：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p><p>进入安装目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd ~</code></pre></div><p>删除原有安装（如果有的话）</p><div class="code-wrapper"><pre><code class="hljs">$ rm -rf nginx$ rm -rf nginx-1.14.2</code></pre></div><p>解压</p><div class="code-wrapper"><pre><code class="hljs">$ tar -zxvf nginx-1.14.2.tar.gz</code></pre></div><p>进入安装目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd nginx-1.14.2</code></pre></div><p>配置(使用openssl、pcre、zlib的源码路径)</p><div class="code-wrapper"><pre><code class="hljs">$ ./configure \--user=nginx \--group=nginx \--prefix=/home/nignx/nginx \--with-http_ssl_module \--with-openssl=/home/nignx/openssl-1.1.0j \--with-pcre=/home/nignx/pcre-8.43 \--with-zlib=/home/nignx/zlib-1.2.11 \--with-http_stub_status_module \--with-threads</code></pre></div><p>编译安装</p><div class="code-wrapper"><pre><code class="hljs">$ make &amp;&amp; make install</code></pre></div><p>修改监听端口为非1024</p><div class="code-wrapper"><pre><code class="hljs">$ vi ~/nginx/conf/nginx.confserver &#123;    listen      8089;    server_name localhost;    location &#123;        root    html;        index   index.html  index.htm;    &#125;&#125;</code></pre></div><p>验证</p><div class="code-wrapper"><pre><code class="hljs">$ /home/nginx/nginx/sbin/nginx -Vnginx version: nginx/1.14.2built by gcc 4.4.7 20120313 (Red Hat 4.4.7-11) (GCC) built with OpenSSL 1.1.0j  20 Nov 2018TLS SNI support enabledconfigure arguments: --user=nginx --group=nginx --prefix=/home/nginx/nginx --with-http_ssl_module --with-openssl=/home/nginx/openssl-1.1.0j --with-pcre=/home/nginx/pcre-8.43 --with-zlib=/home/nginx/zlib-1.2.11 --with-http_stub_status_module --with-threads</code></pre></div><h1 id="启动、重启、停止"><a href="#启动、重启、停止" class="headerlink" title="启动、重启、停止"></a>启动、重启、停止</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><div class="code-wrapper"><pre><code class="hljs">$ /home/nginx/nginx/sbin/nginx</code></pre></div><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><div class="code-wrapper"><pre><code class="hljs">$ /home/nginx/nginx/sbin/nginx -s reload</code></pre></div><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p>查询nginx主进程号</p><div class="code-wrapper"><pre><code class="hljs">$ ps -ef | grep nginx</code></pre></div><p>停止进程</p><div class="code-wrapper"><pre><code class="hljs">$ kill -QUIT 主进程号</code></pre></div><p>快速停止</p><div class="code-wrapper"><pre><code class="hljs">$ kill -TERM 主进程号</code></pre></div><p>强制停止</p><div class="code-wrapper"><pre><code class="hljs">$ pkill -9 nginx</code></pre></div><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试端口</p><div class="code-wrapper"><pre><code class="hljs">$ netstat –na|grep 8089</code></pre></div><p>浏览器中测试<br>    $ curl localhost:8089</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx/OpenResty</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

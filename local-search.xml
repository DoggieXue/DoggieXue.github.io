<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mac系统安装OpenResty及使用</title>
    <link href="/2022/03/17/Mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85OpenResty%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/03/17/Mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85OpenResty%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://openresty.org/cn/installation.html">OpenResty官方安装文档</a>强烈推荐MacOS使用<a href="https://brew.sh/">homebrew</a>包管理工具安装 。但是，对于使用老版本Mac系统（如10.13.6）的用户来说不是很友好，安装过程可能会找不到各种依赖、变量等，不如手动编译源码安装OpenResty。<br>参考<a href="https://www.runoob.com/w3cnote/openresty-intro.html">Linux下安装OpenResty</a>在Mac上编译安装：</p><h1 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h1><p>安装OpenResty前确保当前机器有以下依赖库：<br>● perl 5.6.1+<br>● libreadline<br>● libpcre<br>● libssl</p><p>参考<a href="https://www.toutiao.com/i7064948180328202766/?group_id=7064948180328202766">Linux系统非root用户下安装Nginx</a>安装pcre和openssl即可。</p><h1 id="下载源码包、编译、安装"><a href="#下载源码包、编译、安装" class="headerlink" title="下载源码包、编译、安装"></a>下载源码包、编译、安装</h1><div class="code-wrapper"><pre><code class="hljs">wget https://openresty.org/download/openresty-1.19.3.2.tar.gztar xzvf openresty-1.19.3.2.tar.gz       # 解压cd openresty-1.19.3.2/ ./configuremake make install</code></pre></div><p>默认情况下程序会被安装到 &#x2F;usr&#x2F;local&#x2F;openresty 目录。<strong>该目录下的nginx目录就是独立的Nginx服务</strong>。</p><img src="/2022/03/17/Mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85OpenResty%E5%8F%8A%E4%BD%BF%E7%94%A8/1644593016315-29c058d3-c3ce-4b78-bc94-7c9906b05b29.png" class=""><h1 id="配置PATH环境变量"><a href="#配置PATH环境变量" class="headerlink" title="配置PATH环境变量"></a>配置PATH环境变量</h1><p>方便操作OpenResty，因为Nginx&#x2F;OpenResty发布包中并没有提供好的启动、停止脚本，配置完后，就可以在终端直接使用nginx命令了。</p><div class="code-wrapper"><pre><code class="hljs">vi ~/.zshrc#添加如下配置export PATH=/usr/local/openresty/nginx/sbin:$PATH</code></pre></div><h1 id="命令及参数详解"><a href="#命令及参数详解" class="headerlink" title="命令及参数详解"></a>命令及参数详解</h1><p>OpenResty 的原始启动命令为 nginx，其参数有-v、-t、-p、-c、-s 等，使用说明如下：</p><h2 id="v参数"><a href="#v参数" class="headerlink" title="-v参数"></a>-v参数</h2><p>表示查看Nginx版本</p><div class="code-wrapper"><pre><code class="hljs">➜  ~ nginx -vnginx version: openresty/1.13.6.2</code></pre></div><h2 id="c参数"><a href="#c参数" class="headerlink" title="-c参数"></a>-c参数</h2><p>指定一个Nginx配置文件来替换默认的Nginx配置文件</p><div class="code-wrapper"><pre><code class="hljs">#单独建一个目录，并在目录中创建logs和conf目录mkdir ~/Software/openresty/workcd ~/Software/openresty/workmkdir logs/ conf/</code></pre></div><p>在conf目录下，定义一个后缀为.conf的文件，文件内容如下</p><div class="code-wrapper"><pre><code class="hljs">worker_processes  1;error_log logs/error.log;events &#123;    worker_connections 1024;&#125;http &#123;    server &#123;        listen 8080;        location / &#123;            default_type text/html;            content_by_lua &#39;                ngx.say(&quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;)            &#39;;        &#125;    &#125;&#125;</code></pre></div><p>启动Nginx：</p><div class="code-wrapper"><pre><code class="hljs">#若在上一步新建的目录下：cd ~/Software/openresty/work#执行下面的命令启动➜  work nginx -p ./ -c conf/nginx.conf #若在其他目录，比如用户目录➜  ~ nginx -c ~/Software/openresty/work/conf/nginx.conf </code></pre></div><img src="/2022/03/17/Mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85OpenResty%E5%8F%8A%E4%BD%BF%E7%94%A8/1644594219385-db85a29b-01e6-4282-886b-29d19cb6d425.png" class=""><h2 id="p参数"><a href="#p参数" class="headerlink" title="-p参数"></a>-p参数</h2><p><strong>表示设置前缀路径</strong><br>“-p .&#x2F;”表示将当前目录作为前缀路径，也就是说-c后面指定的配置文件conf&#x2F;nginx.conf中，所用到的相对路径都加上这个前缀。<br>“-p .&#x2F;“ 等价于 “-p <code>pwd</code>&#x2F;“</p><h2 id="t参数"><a href="#t参数" class="headerlink" title="-t参数"></a>-t参数</h2><p><strong>表示测试Nginx配置文件语法是否正确</strong><br>若不能确定编写的Nginx配置文件语法的正确性，就使用-t参数，指定某个配置文件进行检测。不加配置文件路径，默认检测Nginx服务目录下的配置文件。</p><img src="/2022/03/17/Mac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85OpenResty%E5%8F%8A%E4%BD%BF%E7%94%A8/1644594581627-4c4703be-d9f2-4a15-b49b-bdd8eeae324b.png" class=""><h2 id="s参数"><a href="#s参数" class="headerlink" title="-s参数"></a>-s参数</h2><p><strong>表示给Nginx进程发送信号，包含stop(停止)、reload（重新加载）</strong></p><div class="code-wrapper"><pre><code class="hljs">➜  ~ nginx -p ~/Software/openresty/work/ -c conf/nginx.conf -s reload➜  ~ ➜  ~ ps -ef|grep nginx                                                   0  1564     1   0 11:09下午 ??         0:00.00 nginx: master process nginx    -2  1565  1564   0 11:09下午 ??         0:00.00 nginx: worker process    0  2345     1   0 11:40下午 ??         0:00.01 nginx: master process nginx -p ./ -c conf/nginx.conf        -2  2833  2345   0 11:51下午 ??         0:00.00 nginx: worker process        501  2845   495   0 11:51下午 ttys000    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox nginx➜  ~ ➜  ~ ➜  ~ nginx -p ~/Software/openresty/work/ -c conf/nginx.conf -s stop  ➜  ~ ➜  ~ ps -ef|grep nginx    0  1564     1   0 11:09下午 ??         0:00.00 nginx: master process nginx    -2  1565  1564   0 11:09下午 ??         0:00.00 nginx: worker process    501  2882   495   0 11:52下午 ttys000    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox nginx➜  ~ </code></pre></div><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>终端下输入curl <a href="http://localhost:8080/">http://localhost:8080</a></p><div class="code-wrapper"><pre><code class="hljs">➜  ~ curl http://localhost:8080&lt;p&gt;Hello, World!&lt;/p&gt;➜  ~ </code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx/OpenResty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx/OpenResty理论基础</title>
    <link href="/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>Nginx是一个高性能的HTTP和反向代理服务器，生产场景中几乎都会用到，利用Nginx+Lua可以实现高并发编程。<br>Nginx有以下三个社区分支：<br>● Nginx官方：更新迭代快，提供免费版和商业版。<br>● Tengine：是由淘宝网发起的Web服务器项目。在Nginx的基础上针对大访问量网站的需求添加了很多高级的特性和功能。<br>● OpenResty：将LuaJIT VM 嵌入Nginx中，实现了OpenResty这个高性能服务端解决方案。OpenResty是一个基于Nginx和Lua的高性能Web平台，其内部集成了大量精良的Lua库，第三方模块以及大多数的依赖项，用于方便地搭建能够处理超高并发、扩展性极高的动态Web应用、Web服务和动态网关。</p><p>OpenResty的目标是让Web服务直接跑在Nginx服务内部，充分利用Nginx的非阻塞I&#x2F;O模型，不仅对HTTP客户端请求，甚至对远程后端（MySQL、PostgreSQL、memcached及Redis）都进行一致的高性能响应。<br>OpenResty通过汇聚各种设计精良的Nginx模块，从而将Nginx有效地变成了强大的通用Web应用平台，使得Web开发工程师和系统开发工程师可以使用Lua脚本语言调用Nginx支持的各种C及Lua模块，快速构造出足以胜任10KB乃至1000KB以上单机并发连接的高性能Web应用系统。</p><h1 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h1><p>两者都是代理服务中，进行客户端请求的转发</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>客户端非常明确要访问的服务器地址，客户端需要配置目标服务器的IP和端口信息。一般来说，正向代理服务器是一台和客户端网络连通的局域网内部的机器或者是可以打通两个隔离网络的双网卡机器。通过正向代理，客户端的HTTP请求可以转发到之前与客户端网络不通的其他不同的目标服务器。<br>正向代理的主要场景是客户端。由于网络不通等物理原因，需要通过正向代理服务器这种中间转发环节顺利访问目标服务器，也可以通过正向代理服务器对客户端某些信息进行一些伪装和改变。</p><img src="/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1645099365279-7c2cbd04-5290-4eae-bd13-41dbd1824650.png" class=""><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>客户端不知道目标服务器的信息，代理服务器就像是原始的目标服务器，客户端不需要进行任何特别的设置。反向代理最大的特点是客户端不知道目标服务器地址。<br>反向代理的主要场景是服务端。服务提供方可以通过反向代理服务器轻松实现目标服务器的动态切换，实现多目标服务器的负载均衡等。</p><img src="/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1645099413705-712ae104-c6c4-4715-acd3-1efebbad69df.png" class=""><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正向代理（如Squid、Proxy）是对客户端的伪装，隐藏了客户端的IP、头部或者其他信息，服务器得到的伪装过的客户端信息；<br>反向代理（如Nginx、Apache）是对目标服务器的伪装，隐藏了目标服务器的IP、头部或者其他信息，客户端得到的是伪装过的目标服务器信息。</p><h1 id="Nginx核心原理"><a href="#Nginx核心原理" class="headerlink" title="Nginx核心原理"></a>Nginx核心原理</h1><p>Nginx的核心原理包括Reactor模型、Nginx的模块化设计、Nginx的请求处理阶段。</p><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p>Nginx对高并发IO的处理使用了Reactor事件驱动模型。该模型的基本组件有<br>● 事件收集器：负责收集worker进程的各种I&#x2F;O请求。<br>● 事件发送器：负责将IO事件发送到事件处理器。<br>● 事件处理器：负责各种事件的响应工作。</p><p><strong>Reactor模型的核心思想是</strong>：基于操作系统提供的多路I&#x2F;O复用技术，将所有要处理的I&#x2F;O事件注册到一个中心I&#x2F;O多路复用器上，同时主线程阻塞在多路复用器上，一旦有I&#x2F;O事件到来或者准备就绪(文件描述符或Socket可读、写)，多路复用器返回并将事先注册的相应I&#x2F;O事件分发到对应的处理器中。</p><h2 id="Nginx的两类进程"><a href="#Nginx的两类进程" class="headerlink" title="Nginx的两类进程"></a>Nginx的两类进程</h2><p>Nginx启动后会以daemon方式在后台运行，其后台有两类进程：<br>● <strong>Master</strong>进程：又叫管理者进程。主要负责调度Worker工作进程，比如加载配置文件、启动工作进程、接收来自外界的信号、向各Worker进程发送信号、监控Worker进程的运行状态等。同时负责创建监听套接字接口，交由Worker进程进行监听。<br>● <strong>Worker</strong>进程：又叫工作进程。主要用来处理网络事件，当一个Worker进程在接收一个连接通道后，就开始读取请求、解析请求、处理请求，处理完成产生数据后，再返回给客户端，最后断开连接通道。各Worker进程之间是对等且独立的，它们同等竞争来自客户端的请求，一个请求只能在一个Worker进程中处理。</p><h2 id="Nginx的模块化设计"><a href="#Nginx的模块化设计" class="headerlink" title="Nginx的模块化设计"></a>Nginx的模块化设计</h2><p>高度模块化的设计是Nginx的架构基础。各模块之间严格遵循“高内聚、低耦合”的原则。在Nginx实现中，一个模块包含一系列命令（cmd）和这些命令相对应的处理函数（cmd-&gt;handler）。Nginx的Worker进程在执行过程中会通过配置文件的配置指令定位到对应的功能模块的某个命令，然后调用命令对应的处理函数来完成相应的处理。<br>Nginx的模块结构图：</p><img src="/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1645100303761-ebe6a415-a624-4a6c-bd49-5f67ce5e4915.png" class=""><p>Nginx的主要模块说明：<br>● Core核心模块：是Nginx服务器正常运行必不可少的模块，提供错误日志记录、配置文件解析、Reactor事件驱动机制、进程管理等核心功能。<br>● 标准HTTP模块：主要提供HTTP协议解析相关的功能，比如端口配置、网页编码设置、HTTP响应头设置等。<br>● 可选HTTP模块：主要用于扩展标准的HTTP功能，让Nginx能处理一些特殊的服务，如Flash多媒体传输、网络传输压缩、安全协议SSL的支持。<br>● 邮件服务模块：主要用于支持Nginx的邮件服务，包括对POP3协议、IMAP协议和SMTP协议的支持。<br>● 第三方模块：为了扩展Nginx服务器功能，定制开发的，如JSON支持、Lua支持。</p><h2 id="Nginx配置文件上下文结构"><a href="#Nginx配置文件上下文结构" class="headerlink" title="Nginx配置文件上下文结构"></a>Nginx配置文件上下文结构</h2><p>Nginx配置文件包含若干配置项，每个配置项由配置指令和指令参数两部分组成。<br>Nginx的配置项的具体功能与其所处的作用域（上下文、配置块）是强相关的。Nginx指令的作用域配置块大致分为5种，其层次关系如图：</p><img src="/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1645100554585-c8477054-2a67-4405-a2d2-b49f84dbd1d5.png" class=""><p>一个标准的Nginx基本配置文件nginx.conf上下文结构如下：</p><div class="code-wrapper"><pre><code class="hljs">... #main全局配置快，可配置工作进程数events &#123; #事件处理模型配置块，例如IO读写模型、连接数等    ...  &#125;http &#123; #http协议配置块    ... #http协议的全局配置快server &#123; #虚拟服务配置块1        location [PATTERN] &#123; #路由规则配置快1        ...    &#125;        location [PATTERN] &#123; #路由规则配置快2        ...    &#125;&#125;server &#123; #虚拟服务配置块2    ...&#125;... #其他http协议的全局配置&#125;main &#123;    #mail服务配置块    ...     #email相关协议，如SMTP、IMAP、POP3等&#125;</code></pre></div><p>除了基本配置文件外，Nginx还有如下配置文件：<br>● mime.type：与MIME类型相关的配置文件<br>● fastcgi.conf：与FastCGI相关的配置文件。<br>● proxy.conf：与Proxy相关的配置文件。<br>● sites.conf：单独配置Nginx的提供的虚拟主机。</p><h2 id="Nginx的请求处理流程"><a href="#Nginx的请求处理流程" class="headerlink" title="Nginx的请求处理流程"></a>Nginx的请求处理流程</h2><p>Nginx中HTTP请求的处理流程可以分为4步：</p><ol><li>读取解析请求行；</li><li>读取解析请求头；</li><li>多阶段处理，即执行handle处理器列表；</li><li>将结果返回给客户端<br>Nginx把HTTP请求处理划分成了11个阶段，在完成前两步处理后，Nginx将整个请求封装到一个请求结构体ngx_http_request_t实例中，该实例相当于一个Java对象，然后进入多阶段处理，执行handler处理器列表，列表中的每个handler处理器都会对请求对象进行处理，类似于Netty中的PipeLine。</li></ol><p>在Nginx进行多阶段处理时，handler处理器的执行次序除了和配置文件中对应指令的配置顺序相关外，还和指令所处的阶段先后次序相关。如下如展示了多阶段处理的顺序：</p><img src="/2022/02/17/Nginx-OpenResty%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/c063ac3fcb254d778b847ac771a7dfe6.jpeg" class=""><h2 id="HTTP请求处理的11个阶段"><a href="#HTTP请求处理的11个阶段" class="headerlink" title="HTTP请求处理的11个阶段"></a>HTTP请求处理的11个阶段</h2><ol><li>post-read阶段：标准模块的ngx_realip处理器就注册在该阶段。改写请求的来源地址，将客户端真实IP附加上，便于后端获取。</li><li>server-rewrite阶段：server块中请求地址重写阶段。</li><li>find-config阶段：配置查找阶段，根据请求URL地址去匹配location路由表达式。不支持Nginx模块注册处理程序。</li><li>rewrite阶段：请求地址重写阶段，此时，location配置块中的指令开始起作用，如breaker、if、return、rewrite、set等，三方库ngx_lua模块中的set_by_lua、rewrite_by_lua指令也注册在此阶段.</li><li>post-rewrite阶段：请求地址URI重写后提交阶段，防止递归修改URI造成死循环。不支持Nginx模块注册处理程序。</li><li>preaccess阶段：访问权限检查准备阶段。</li><li>access阶段：访问权限检查阶段。注册在该阶段的指令有ngx_http_access_module模块的指令、三方ngx_auth_request模块的指令、ngx_lua模块的指令。特别提醒：echo指令用于返回内容，在location上下文中，该指令注册在content阶段，access阶段不执行该指令的配置项。</li><li>post-access阶段：访问权限检查提交阶段。如果请求不被允许访问Nginx服务器，该阶段负责向用户返回错误响应。不支持Nginx模块注册处理程序。在access阶段可能存在多个访问控制模块的指令注册，该阶段    的satisfy指令可以用于控制它们的协作方式：<br>  a. 逻辑或操作：satisfy any。表示访问控制模块A、B、C或更多，只要其中任意一个通过就算通过。<br>  b. 逻辑与操作：satisfy all。表示访问控制模块A、B、C或更多，全部通过才算通过。</li><li>try-files阶段：可以使请求按顺序访问多个静态文件资源，直到某个静态文件资源符合条件。不支持Nginx模块注册处理程序。</li><li>content阶段：内容产生阶段，大部分HTTP模块会介入。Nginx的echo、ngx_lua中的content_by_lua指令就注册在该阶段</li><li>log阶段：日志记录模块。</li></ol><p>Nginx将一个HTTP请求分为11个处理阶段，这样做让每个HTTP模块可以只专注于完成一个独立、简单的功能。而一个请求的完整处理过程由多个HTTP模块共同完成，可以极大地提高多个模块合作的协同性、可测试性和可扩展性。<br>同一个阶段内的指令，Nginx会按照各个指令的上下文顺序执行对应的handle处理器方法。</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx/OpenResty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用非root用户停止和启动Apache、Nginx的方法</title>
    <link href="/2019/12/31/%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%81%9C%E6%AD%A2%E5%92%8C%E5%90%AF%E5%8A%A8Apache%E3%80%81Nginx%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2019/12/31/%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E5%81%9C%E6%AD%A2%E5%92%8C%E5%90%AF%E5%8A%A8Apache%E3%80%81Nginx%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Apache或Nginx运行时会监听80或者443端口，root权限被回收后，修改配置文件需要重启的情况下，可以通过给二进制文件set UID的方式实现。</p><h1 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h1><p>root用户登录进入到&#x2F;opt&#x2F;apache&#x2F;bin目录下</p><div class="code-wrapper"><pre><code class="hljs"># cd /opt/apache/bin# chown root httpd# chmod u+s httpd# su - chatweb$ ll httpd -rwsr-xr-x 1 root chatweb 1546353 2017-08-14 httpd$ /opt/apache/bin/apachectl start</code></pre></div><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>root用户进入&#x2F;…&#x2F;nginx&#x2F;sbin目录下</p><div class="code-wrapper"><pre><code class="hljs"># cd /.../nginx/sbin# chown root nginx# chmod u+s nginx# su - nginx$ ll nginx-rwsr-xr-x 1 root nginx 3289160 2019-05-05 nginx$ /.../nginx/sbin/nginx -s reload</code></pre></div><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Linux系统中的文件除了user id和group id外，还有俩称之为effective的id，四个id简写为uid、gid和euid、egid。<br>内核主要是根据euid和egid来确定进程对资源的访问权限：</p><ul><li>一个进程如果没有SUID或SGID位，则euid&#x3D;uid egid&#x3D;gid，分别是运行这个程序的用户的uid和gid；  </li><li>如果一个程序设置了SUID，则euid和egid变成被运行的程序的所有者的uid和gid；  </li><li>SUID的优先级比SGID高，当一个可执行程序设置了SUID，则SGID会自动变成相应的egid</li></ul><p>set UID（SUID）的作用是让执行该命令的用户以该命令拥有者的权限去执行。假如启动命令的拥有者是root用户，普通用户执行命令时就会拥有root的权限，然后使用root权限去操作服务。<br>set UID的方式只针对二进制文件，是在执行程序（程序的可执行位被设置）时起作用，而可执行位只对普通文件和目录文件有意义。</p><p>给文件加或去掉SUID和SGID的命令如下：</p><div class="code-wrapper"><pre><code class="hljs"># chmod u+s filename 设置SUID位# chmod u-s filename 去掉SUID设置# chmod g+s filename 设置SGID位# chmod g-s filename 去掉SGID设置</code></pre></div><p>如果一个文件被设置了SUID或SGID位，会分别表现在所有者或同组用户的权限的可执行位上。例如：<br>1、-rwsr-xr-x 表示SUID和所有者权限中可执行位被设置<br>2、-rwSr–r– 表示SUID被设置，但所有者权限中可执行位没有被设置<br>3、-rwxr-sr-x 表示SGID和同组用户权限中可执行位被设置<br>4、-rw-r-Sr– 表示SGID被设置，但同组用户权限中可执行位没有被设置</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Nginx</category>
      
      <category>Apache</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx/OpenResty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统非root用户下安装Nginx</title>
    <link href="/2019/04/28/Linux%E7%B3%BB%E7%BB%9F%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/"/>
    <url>/2019/04/28/Linux%E7%B3%BB%E7%BB%9F%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/</url>
    
    <content type="html"><![CDATA[<p>通常使用Nginx或者Apache作为Web服务器时，默认监听80端口，因此默认会使用root用户去安装，而且，使用yum命令安装时，通常会安装到默认的路径下，默认路径通常是root用户才有执行权限的。如果不需要使用Nginx监听1024以下的端口，且对权限和网络管理比较严格时，能用非root权限解决的，就用普通用户。在此使用编译Nginx源码的方式安装Nginx。 假设已拿到root用户权限，但需要使用普通用户去管理Nginx。</p><h1 id="登录Linux服务器"><a href="#登录Linux服务器" class="headerlink" title="登录Linux服务器"></a>登录Linux服务器</h1><p>root登录服务器<br>    ssh <a href="mailto:&#114;&#111;&#111;&#x74;&#64;&#x78;&#x2e;&#x78;&#x2e;&#x78;&#x2e;&#x78;">&#114;&#111;&#111;&#x74;&#64;&#x78;&#x2e;&#x78;&#x2e;&#x78;&#x2e;&#x78;</a></p><h1 id="创建普通用户并设置密码"><a href="#创建普通用户并设置密码" class="headerlink" title="创建普通用户并设置密码"></a>创建普通用户并设置密码</h1><p>创建普通用户</p><div class="code-wrapper"><pre><code class="hljs"># useradd nginx</code></pre></div><p>为nginx用户设置密码为nginx#123</p><div class="code-wrapper"><pre><code class="hljs"># echo nginx#123|passwd --stdin nginx</code></pre></div><p>创建完毕用户后，切换到nginx用户</p><div class="code-wrapper"><pre><code class="hljs"># su nginx</code></pre></div><p>进入用户目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd ~</code></pre></div><h1 id="安装openssl"><a href="#安装openssl" class="headerlink" title="安装openssl"></a>安装openssl</h1><p><a href="https://www.openssl.org/source/">下载地址</a></p><p>进入用户目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd ~</code></pre></div><p>删除原有安装（如果有的话）</p><div class="code-wrapper"><pre><code class="hljs">$ rm -rf openssl$ rm -rf openssl-1.1.0j #（以机器上实际安装的为准）</code></pre></div><p>解压</p><div class="code-wrapper"><pre><code class="hljs">$ tar -zxv -f openssl-1.1.0j.tar.gz</code></pre></div><p>进入源码目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd openssl-1.1.0j</code></pre></div><p>配置<br>注意，prefix和opensslsir的值要写绝对路径，不能是相对路径，表示编译后的地址</p><div class="code-wrapper"><pre><code class="hljs">$ ./config --prefix=/home/nginx/openssl --openssldir=/home/nginx/openssl/conf</code></pre></div><p>编译安装</p><div class="code-wrapper"><pre><code class="hljs">$ make &amp;&amp; make install</code></pre></div><p>检查安装</p><div class="code-wrapper"><pre><code class="hljs">$ cd /home/nginx/openssl/bin$ openssl version -a</code></pre></div><h1 id="安装pcre"><a href="#安装pcre" class="headerlink" title="安装pcre"></a>安装pcre</h1><p>下载地址：<br><a href="https://sourceforge.net/projects/pcre/">https://sourceforge.net/projects/pcre/</a></p><p>进入安装目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd ~</code></pre></div><p>删除原有安装（如果有的话）</p><div class="code-wrapper"><pre><code class="hljs">$ rm -rf pcre$ rm -rf pcre-8.43 （以机器上实际安装的为准）</code></pre></div><p>解压</p><div class="code-wrapper"><pre><code class="hljs">$ tar -zxv -f pcre-8.43.tar.gz</code></pre></div><p>进入源码目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd pcre-8.43</code></pre></div><p>执行配置</p><div class="code-wrapper"><pre><code class="hljs">$./configure --prefix=/home/nginx/pcre/</code></pre></div><p>编译安装</p><div class="code-wrapper"><pre><code class="hljs">$ make &amp;&amp; make install</code></pre></div><h1 id="安装zlib"><a href="#安装zlib" class="headerlink" title="安装zlib"></a>安装zlib</h1><p>下载地址：<a href="http://zlib.net/">http://zlib.net/</a></p><p>进入安装目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd ~</code></pre></div><p>删除原有安装（如果有的话）</p><div class="code-wrapper"><pre><code class="hljs">$ rm -rf zlib$ rm -rf zlib-1.2.11（以机器上实际安装的为准）</code></pre></div><p>解压</p><div class="code-wrapper"><pre><code class="hljs">$ tar -zxv -f zlib-1.2.11.tar.gz</code></pre></div><p>进入源码目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd zlib-1.2.11</code></pre></div><p>配置</p><div class="code-wrapper"><pre><code class="hljs">$./configure --prefix=/home/nginx/zlib/</code></pre></div><p>编译安装</p><div class="code-wrapper"><pre><code class="hljs">$ make &amp;&amp; make install</code></pre></div><h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><p>下载地址：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p><p>进入安装目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd ~</code></pre></div><p>删除原有安装（如果有的话）</p><div class="code-wrapper"><pre><code class="hljs">$ rm -rf nginx$ rm -rf nginx-1.14.2</code></pre></div><p>解压</p><div class="code-wrapper"><pre><code class="hljs">$ tar -zxvf nginx-1.14.2.tar.gz</code></pre></div><p>进入安装目录</p><div class="code-wrapper"><pre><code class="hljs">$ cd nginx-1.14.2</code></pre></div><p>配置(使用openssl、pcre、zlib的源码路径)</p><div class="code-wrapper"><pre><code class="hljs">$ ./configure \--user=nginx \--group=nginx \--prefix=/home/nignx/nginx \--with-http_ssl_module \--with-openssl=/home/nignx/openssl-1.1.0j \--with-pcre=/home/nignx/pcre-8.43 \--with-zlib=/home/nignx/zlib-1.2.11 \--with-http_stub_status_module \--with-threads</code></pre></div><p>编译安装</p><div class="code-wrapper"><pre><code class="hljs">$ make &amp;&amp; make install</code></pre></div><p>修改监听端口为非1024</p><div class="code-wrapper"><pre><code class="hljs">$ vi ~/nginx/conf/nginx.confserver &#123;    listen      8089;    server_name localhost;    location &#123;        root    html;        index   index.html  index.htm;    &#125;&#125;</code></pre></div><p>验证</p><div class="code-wrapper"><pre><code class="hljs">$ /home/nginx/nginx/sbin/nginx -Vnginx version: nginx/1.14.2built by gcc 4.4.7 20120313 (Red Hat 4.4.7-11) (GCC) built with OpenSSL 1.1.0j  20 Nov 2018TLS SNI support enabledconfigure arguments: --user=nginx --group=nginx --prefix=/home/nginx/nginx --with-http_ssl_module --with-openssl=/home/nginx/openssl-1.1.0j --with-pcre=/home/nginx/pcre-8.43 --with-zlib=/home/nginx/zlib-1.2.11 --with-http_stub_status_module --with-threads</code></pre></div><h1 id="启动、重启、停止"><a href="#启动、重启、停止" class="headerlink" title="启动、重启、停止"></a>启动、重启、停止</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><div class="code-wrapper"><pre><code class="hljs">$ /home/nginx/nginx/sbin/nginx</code></pre></div><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><div class="code-wrapper"><pre><code class="hljs">$ /home/nginx/nginx/sbin/nginx -s reload</code></pre></div><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p>查询nginx主进程号</p><div class="code-wrapper"><pre><code class="hljs">$ ps -ef | grep nginx</code></pre></div><p>停止进程</p><div class="code-wrapper"><pre><code class="hljs">$ kill -QUIT 主进程号</code></pre></div><p>快速停止</p><div class="code-wrapper"><pre><code class="hljs">$ kill -TERM 主进程号</code></pre></div><p>强制停止</p><div class="code-wrapper"><pre><code class="hljs">$ pkill -9 nginx</code></pre></div><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试端口</p><div class="code-wrapper"><pre><code class="hljs">$ netstat –na|grep 8089</code></pre></div><p>浏览器中测试<br>    $ curl localhost:8089</p>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx/OpenResty</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
